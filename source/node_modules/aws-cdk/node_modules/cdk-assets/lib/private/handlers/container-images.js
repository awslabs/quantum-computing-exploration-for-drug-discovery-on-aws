"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerImageAssetHandler = void 0;
const path = require("path");
const progress_1 = require("../../progress");
const docker_1 = require("../docker");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
class ContainerImageAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.docker = new docker_1.Docker(m => this.host.emitMessage(progress_1.EventType.DEBUG, m));
    }
    async publish() {
        const destination = await placeholders_1.replaceAwsPlaceholders(this.asset.destination, this.host.aws);
        const ecr = await this.host.aws.ecrClient(destination);
        const account = async () => { var _a; return (_a = (await this.host.aws.discoverCurrentAccount())) === null || _a === void 0 ? void 0 : _a.accountId; };
        const repoUri = await repositoryUri(ecr, destination.repositoryName);
        if (!repoUri) {
            throw new Error(`No ECR repository named '${destination.repositoryName}' in account ${await account()}. Is this account bootstrapped?`);
        }
        const imageUri = `${repoUri}:${destination.imageTag}`;
        if (await this.destinationAlreadyExists(ecr, destination, imageUri)) {
            return;
        }
        if (this.host.aborted) {
            return;
        }
        // Default behavior is to login before build so that the Dockerfile can reference images in the ECR repo
        // However, if we're in a pipelines environment (for example),
        // we may have alternative credentials to the default ones to use for the build itself.
        // If the special config file is present, delay the login to the default credentials until the push.
        // If the config file is present, we will configure and use those credentials for the build.
        let cdkDockerCredentialsConfigured = this.docker.configureCdkCredentials();
        if (!cdkDockerCredentialsConfigured) {
            await this.docker.login(ecr);
        }
        const localTagName = this.asset.source.executable
            ? await this.buildExternalAsset(this.asset.source.executable)
            : await this.buildDirectoryAsset();
        if (localTagName === undefined || this.host.aborted) {
            return;
        }
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Push ${imageUri}`);
        if (this.host.aborted) {
            return;
        }
        await this.docker.tag(localTagName, imageUri);
        if (cdkDockerCredentialsConfigured) {
            this.docker.resetAuthPlugins();
            await this.docker.login(ecr);
        }
        await this.docker.push(imageUri);
    }
    /**
     * Build a (local) Docker asset from a directory with a Dockerfile
     *
     * Tags under a deterministic, unique, local identifier wich will skip
     * the build if it already exists.
     */
    async buildDirectoryAsset() {
        const localTagName = `cdkasset-${this.asset.id.assetId.toLowerCase()}`;
        if (!(await this.isImageCached(localTagName))) {
            if (this.host.aborted) {
                return undefined;
            }
            await this.buildImage(localTagName);
        }
        return localTagName;
    }
    /**
     * Build a (local) Docker asset by running an external command
     *
     * External command is responsible for deduplicating the build if possible,
     * and is expected to return the generated image identifier on stdout.
     */
    async buildExternalAsset(executable, cwd) {
        const assetPath = cwd !== null && cwd !== void 0 ? cwd : this.workDir;
        this.host.emitMessage(progress_1.EventType.BUILD, `Building Docker image using command '${executable}'`);
        if (this.host.aborted) {
            return undefined;
        }
        return (await shell_1.shell(executable, { cwd: assetPath, quiet: true })).trim();
    }
    /**
     * Check whether the image already exists in the ECR repo
     *
     * Use the fields from the destination to do the actual check. The imageUri
     * should correspond to that, but is only used to print Docker image location
     * for user benefit (the format is slightly different).
     */
    async destinationAlreadyExists(ecr, destination, imageUri) {
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${imageUri}`);
        if (await imageExists(ecr, destination.repositoryName, destination.imageTag)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${imageUri}`);
            return true;
        }
        return false;
    }
    async buildImage(localTagName) {
        const source = this.asset.source;
        if (!source.directory) {
            throw new Error(`'directory' is expected in the DockerImage asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.directory);
        this.host.emitMessage(progress_1.EventType.BUILD, `Building Docker image at ${fullPath}`);
        await this.docker.build({
            directory: fullPath,
            tag: localTagName,
            buildArgs: source.dockerBuildArgs,
            target: source.dockerBuildTarget,
            file: source.dockerFile,
        });
    }
    async isImageCached(localTagName) {
        if (await this.docker.exists(localTagName)) {
            this.host.emitMessage(progress_1.EventType.CACHED, `Cached ${localTagName}`);
            return true;
        }
        return false;
    }
}
exports.ContainerImageAssetHandler = ContainerImageAssetHandler;
async function imageExists(ecr, repositoryName, imageTag) {
    try {
        await ecr.describeImages({ repositoryName, imageIds: [{ imageTag }] }).promise();
        return true;
    }
    catch (e) {
        if (e.code !== 'ImageNotFoundException') {
            throw e;
        }
        return false;
    }
}
/**
 * Return the URI for the repository with the given name
 *
 * Returns undefined if the repository does not exist.
 */
async function repositoryUri(ecr, repositoryName) {
    var _a;
    try {
        const response = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
        return (_a = (response.repositories || [])[0]) === null || _a === void 0 ? void 0 : _a.repositoryUri;
    }
    catch (e) {
        if (e.code !== 'RepositoryNotFoundException') {
            throw e;
        }
        return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLWltYWdlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnRhaW5lci1pbWFnZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkJBQTZCO0FBRzdCLDZDQUEyQztBQUUzQyxzQ0FBbUM7QUFDbkMsa0RBQXlEO0FBQ3pELG9DQUFpQztBQUVqQyxNQUFhLDBCQUEwQjtJQUdyQyxZQUNtQixPQUFlLEVBQ2YsS0FBK0IsRUFDL0IsSUFBa0I7UUFGbEIsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNmLFVBQUssR0FBTCxLQUFLLENBQTBCO1FBQy9CLFNBQUksR0FBSixJQUFJLENBQWM7UUFMcEIsV0FBTSxHQUFHLElBQUksZUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsb0JBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQU1yRixDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDbEIsTUFBTSxXQUFXLEdBQUcsTUFBTSxxQ0FBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hGLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3ZELE1BQU0sT0FBTyxHQUFHLEtBQUssSUFBSSxFQUFFLHdCQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLDBDQUFFLFNBQVMsR0FBQSxDQUFDO1FBQ3RGLE1BQU0sT0FBTyxHQUFHLE1BQU0sYUFBYSxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFckUsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJB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QUFZLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLDBDQUFFLGFBQWEsQ0FBQztLQUN4RDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLDZCQUE2QixFQUFFO1lBQUUsTUFBTSxDQUFDLENBQUM7U0FBRTtRQUMxRCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgRG9ja2VySW1hZ2VEZXN0aW5hdGlvbiB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgeyBEb2NrZXJJbWFnZU1hbmlmZXN0RW50cnkgfSBmcm9tICcuLi8uLi9hc3NldC1tYW5pZmVzdCc7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tICcuLi8uLi9wcm9ncmVzcyc7XG5pbXBvcnQgeyBJQXNzZXRIYW5kbGVyLCBJSGFuZGxlckhvc3QgfSBmcm9tICcuLi9hc3NldC1oYW5kbGVyJztcbmltcG9ydCB7IERvY2tlciB9IGZyb20gJy4uL2RvY2tlcic7XG5pbXBvcnQgeyByZXBsYWNlQXdzUGxhY2Vob2xkZXJzIH0gZnJvbSAnLi4vcGxhY2Vob2xkZXJzJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi4vc2hlbGwnO1xuXG5leHBvcnQgY2xhc3MgQ29udGFpbmVySW1hZ2VBc3NldEhhbmRsZXIgaW1wbGVtZW50cyBJQXNzZXRIYW5kbGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBkb2NrZXIgPSBuZXcgRG9ja2VyKG0gPT4gdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5ERUJVRywgbSkpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgd29ya0Rpcjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXNzZXQ6IERvY2tlckltYWdlTWFuaWZlc3RFbnRyeSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGhvc3Q6IElIYW5kbGVySG9zdCkge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHB1Ymxpc2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBhd2FpdCByZXBsYWNlQXdzUGxhY2Vob2xkZXJzKHRoaXMuYXNzZXQuZGVzdGluYXRpb24sIHRoaXMuaG9zdC5hd3MpO1xuICAgIGNvbnN0IGVjciA9IGF3YWl0IHRoaXMuaG9zdC5hd3MuZWNyQ2xpZW50KGRlc3RpbmF0aW9uKTtcbiAgICBjb25zdCBhY2NvdW50ID0gYXN5bmMgKCkgPT4gKGF3YWl0IHRoaXMuaG9zdC5hd3MuZGlzY292ZXJDdXJyZW50QWNjb3VudCgpKT8uYWNjb3VudElkO1xuICAgIGNvbnN0IHJlcG9VcmkgPSBhd2FpdCByZXBvc2l0b3J5VXJpKGVjciwgZGVzdGluYXRpb24ucmVwb3NpdG9yeU5hbWUpO1xuXG4gICAgaWYgKCFyZXBvVXJpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIEVDUiByZXBvc2l0b3J5IG5hbWVkICcke2Rlc3RpbmF0aW9uLnJlcG9zaXRvcnlOYW1lfScgaW4gYWNjb3VudCAke2F3YWl0IGFjY291bnQoKX0uIElzIHRoaXMgYWNjb3VudCBib290c3RyYXBwZWQ/YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VVcmkgPSBgJHtyZXBvVXJpfToke2Rlc3RpbmF0aW9uLmltYWdlVGFnfWA7XG5cbiAgICBpZiAoYXdhaXQgdGhpcy5kZXN0aW5hdGlvbkFscmVhZHlFeGlzdHMoZWNyLCBkZXN0aW5hdGlvbiwgaW1hZ2VVcmkpKSB7IHJldHVybjsgfVxuICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkgeyByZXR1cm47IH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gbG9naW4gYmVmb3JlIGJ1aWxkIHNvIHRoYXQgdGhlIERvY2tlcmZpbGUgY2FuIHJlZmVyZW5jZSBpbWFnZXMgaW4gdGhlIEVDUiByZXBvXG4gICAgLy8gSG93ZXZlciwgaWYgd2UncmUgaW4gYSBwaXBlbGluZXMgZW52aXJvbm1lbnQgKGZvciBleGFtcGxlKSxcbiAgICAvLyB3ZSBtYXkgaGF2ZSBhbHRlcm5hdGl2ZSBjcmVkZW50aWFscyB0byB0aGUgZGVmYXVsdCBvbmVzIHRvIHVzZSBmb3IgdGhlIGJ1aWxkIGl0c2VsZi5cbiAgICAvLyBJZiB0aGUgc3BlY2lhbCBjb25maWcgZmlsZSBpcyBwcmVzZW50LCBkZWxheSB0aGUgbG9naW4gdG8gdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgdW50aWwgdGhlIHB1c2guXG4gICAgLy8gSWYgdGhlIGNvbmZpZyBmaWxlIGlzIHByZXNlbnQsIHdlIHdpbGwgY29uZmlndXJlIGFuZCB1c2UgdGhvc2UgY3JlZGVudGlhbHMgZm9yIHRoZSBidWlsZC5cbiAgICBsZXQgY2RrRG9ja2VyQ3JlZGVudGlhbHNDb25maWd1cmVkID0gdGhpcy5kb2NrZXIuY29uZmlndXJlQ2RrQ3JlZGVudGlhbHMoKTtcbiAgICBpZiAoIWNka0RvY2tlckNyZWRlbnRpYWxzQ29uZmlndXJlZCkgeyBhd2FpdCB0aGlzLmRvY2tlci5sb2dpbihlY3IpOyB9XG5cbiAgICBjb25zdCBsb2NhbFRhZ05hbWUgPSB0aGlzLmFzc2V0LnNvdXJjZS5leGVjdXRhYmxlXG4gICAgICA/IGF3YWl0IHRoaXMuYnVpbGRFeHRlcm5hbEFzc2V0KHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUpXG4gICAgICA6IGF3YWl0IHRoaXMuYnVpbGREaXJlY3RvcnlBc3NldCgpO1xuXG4gICAgaWYgKGxvY2FsVGFnTmFtZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaG9zdC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5VUExPQUQsIGBQdXNoICR7aW1hZ2VVcml9YCk7XG4gICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7IHJldHVybjsgfVxuICAgIGF3YWl0IHRoaXMuZG9ja2VyLnRhZyhsb2NhbFRhZ05hbWUsIGltYWdlVXJpKTtcblxuICAgIGlmIChjZGtEb2NrZXJDcmVkZW50aWFsc0NvbmZpZ3VyZWQpIHtcbiAgICAgIHRoaXMuZG9ja2VyLnJlc2V0QXV0aFBsdWdpbnMoKTtcbiAgICAgIGF3YWl0IHRoaXMuZG9ja2VyLmxvZ2luKGVjcik7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5kb2NrZXIucHVzaChpbWFnZVVyaSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSAobG9jYWwpIERvY2tlciBhc3NldCBmcm9tIGEgZGlyZWN0b3J5IHdpdGggYSBEb2NrZXJmaWxlXG4gICAqXG4gICAqIFRhZ3MgdW5kZXIgYSBkZXRlcm1pbmlzdGljLCB1bmlxdWUsIGxvY2FsIGlkZW50aWZpZXIgd2ljaCB3aWxsIHNraXBcbiAgICogdGhlIGJ1aWxkIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBidWlsZERpcmVjdG9yeUFzc2V0KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgbG9jYWxUYWdOYW1lID0gYGNka2Fzc2V0LSR7dGhpcy5hc3NldC5pZC5hc3NldElkLnRvTG93ZXJDYXNlKCl9YDtcblxuICAgIGlmICghKGF3YWl0IHRoaXMuaXNJbWFnZUNhY2hlZChsb2NhbFRhZ05hbWUpKSkge1xuICAgICAgaWYgKHRoaXMuaG9zdC5hYm9ydGVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICAgICAgYXdhaXQgdGhpcy5idWlsZEltYWdlKGxvY2FsVGFnTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY2FsVGFnTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhIChsb2NhbCkgRG9ja2VyIGFzc2V0IGJ5IHJ1bm5pbmcgYW4gZXh0ZXJuYWwgY29tbWFuZFxuICAgKlxuICAgKiBFeHRlcm5hbCBjb21tYW5kIGlzIHJlc3BvbnNpYmxlIGZvciBkZWR1cGxpY2F0aW5nIHRoZSBidWlsZCBpZiBwb3NzaWJsZSxcbiAgICogYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVybiB0aGUgZ2VuZXJhdGVkIGltYWdlIGlkZW50aWZpZXIgb24gc3Rkb3V0LlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBidWlsZEV4dGVybmFsQXNzZXQoZXhlY3V0YWJsZTogc3RyaW5nW10sIGN3ZD86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG5cbiAgICBjb25zdCBhc3NldFBhdGggPSBjd2QgPz8gdGhpcy53b3JrRGlyO1xuXG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5CVUlMRCwgYEJ1aWxkaW5nIERvY2tlciBpbWFnZSB1c2luZyBjb21tYW5kICcke2V4ZWN1dGFibGV9J2ApO1xuICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICByZXR1cm4gKGF3YWl0IHNoZWxsKGV4ZWN1dGFibGUsIHsgY3dkOiBhc3NldFBhdGgsIHF1aWV0OiB0cnVlIH0pKS50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgaW1hZ2UgYWxyZWFkeSBleGlzdHMgaW4gdGhlIEVDUiByZXBvXG4gICAqXG4gICAqIFVzZSB0aGUgZmllbGRzIGZyb20gdGhlIGRlc3RpbmF0aW9uIHRvIGRvIHRoZSBhY3R1YWwgY2hlY2suIFRoZSBpbWFnZVVyaVxuICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byB0aGF0LCBidXQgaXMgb25seSB1c2VkIHRvIHByaW50IERvY2tlciBpbWFnZSBsb2NhdGlvblxuICAgKiBmb3IgdXNlciBiZW5lZml0ICh0aGUgZm9ybWF0IGlzIHNsaWdodGx5IGRpZmZlcmVudCkuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGRlc3RpbmF0aW9uQWxyZWFkeUV4aXN0cyhlY3I6IEFXUy5FQ1IsIGRlc3RpbmF0aW9uOiBEb2NrZXJJbWFnZURlc3RpbmF0aW9uLCBpbWFnZVVyaTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5DSEVDSywgYENoZWNrICR7aW1hZ2VVcml9YCk7XG4gICAgaWYgKGF3YWl0IGltYWdlRXhpc3RzKGVjciwgZGVzdGluYXRpb24ucmVwb3NpdG9yeU5hbWUsIGRlc3RpbmF0aW9uLmltYWdlVGFnKSkge1xuICAgICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5GT1VORCwgYEZvdW5kICR7aW1hZ2VVcml9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGJ1aWxkSW1hZ2UobG9jYWxUYWdOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmFzc2V0LnNvdXJjZTtcbiAgICBpZiAoIXNvdXJjZS5kaXJlY3RvcnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ2RpcmVjdG9yeScgaXMgZXhwZWN0ZWQgaW4gdGhlIERvY2tlckltYWdlIGFzc2V0IHNvdXJjZSwgZ290OiAke0pTT04uc3RyaW5naWZ5KHNvdXJjZSl9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLnJlc29sdmUodGhpcy53b3JrRGlyLCBzb3VyY2UuZGlyZWN0b3J5KTtcbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkJVSUxELCBgQnVpbGRpbmcgRG9ja2VyIGltYWdlIGF0ICR7ZnVsbFBhdGh9YCk7XG5cbiAgICBhd2FpdCB0aGlzLmRvY2tlci5idWlsZCh7XG4gICAgICBkaXJlY3Rvcnk6IGZ1bGxQYXRoLFxuICAgICAgdGFnOiBsb2NhbFRhZ05hbWUsXG4gICAgICBidWlsZEFyZ3M6IHNvdXJjZS5kb2NrZXJCdWlsZEFyZ3MsXG4gICAgICB0YXJnZXQ6IHNvdXJjZS5kb2NrZXJCdWlsZFRhcmdldCxcbiAgICAgIGZpbGU6IHNvdXJjZS5kb2NrZXJGaWxlLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpc0ltYWdlQ2FjaGVkKGxvY2FsVGFnTmFtZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKGF3YWl0IHRoaXMuZG9ja2VyLmV4aXN0cyhsb2NhbFRhZ05hbWUpKSB7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNBQ0hFRCwgYENhY2hlZCAke2xvY2FsVGFnTmFtZX1gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBpbWFnZUV4aXN0cyhlY3I6IEFXUy5FQ1IsIHJlcG9zaXRvcnlOYW1lOiBzdHJpbmcsIGltYWdlVGFnOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBlY3IuZGVzY3JpYmVJbWFnZXMoeyByZXBvc2l0b3J5TmFtZSwgaW1hZ2VJZHM6IFt7IGltYWdlVGFnIH1dIH0pLnByb21pc2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgIT09ICdJbWFnZU5vdEZvdW5kRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBVUkkgZm9yIHRoZSByZXBvc2l0b3J5IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAqXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgcmVwb3NpdG9yeSBkb2VzIG5vdCBleGlzdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVwb3NpdG9yeVVyaShlY3I6IEFXUy5FQ1IsIHJlcG9zaXRvcnlOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZWNyLmRlc2NyaWJlUmVwb3NpdG9yaWVzKHsgcmVwb3NpdG9yeU5hbWVzOiBbcmVwb3NpdG9yeU5hbWVdIH0pLnByb21pc2UoKTtcbiAgICByZXR1cm4gKHJlc3BvbnNlLnJlcG9zaXRvcmllcyB8fCBbXSlbMF0/LnJlcG9zaXRvcnlVcmk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlICE9PSAnUmVwb3NpdG9yeU5vdEZvdW5kRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuIl19