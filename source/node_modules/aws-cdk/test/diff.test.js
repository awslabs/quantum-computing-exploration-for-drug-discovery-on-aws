"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const string_decoder_1 = require("string_decoder");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cloudformation_deployments_1 = require("../lib/api/cloudformation-deployments");
const cdk_toolkit_1 = require("../lib/cdk-toolkit");
const util_1 = require("./util");
let cloudExecutable;
let cloudFormation;
let toolkit;
beforeEach(() => {
    cloudExecutable = new util_1.MockCloudExecutable({
        stacks: [{
                stackName: 'A',
                template: { resource: 'A' },
            },
            {
                stackName: 'B',
                depends: ['A'],
                template: { resource: 'B' },
            },
            {
                stackName: 'C',
                depends: ['A'],
                template: { resource: 'C' },
                metadata: {
                    '/resource': [
                        {
                            type: cxschema.ArtifactMetadataEntryType.ERROR,
                            data: 'this is an error',
                        },
                    ],
                },
            },
            {
                stackName: 'D',
                template: { resource: 'D' },
            }],
    });
    cloudFormation = util_1.instanceMockFrom(cloudformation_deployments_1.CloudFormationDeployments);
    toolkit = new cdk_toolkit_1.CdkToolkit({
        cloudExecutable,
        cloudFormation,
        configuration: cloudExecutable.configuration,
        sdkProvider: cloudExecutable.sdkProvider,
    });
    // Default implementations
    cloudFormation.readCurrentTemplate.mockImplementation((stackArtifact) => {
        if (stackArtifact.stackName === 'D') {
            return Promise.resolve({ resource: 'D' });
        }
        return Promise.resolve({});
    });
    cloudFormation.deployStack.mockImplementation((options) => Promise.resolve({
        noOp: true,
        outputs: {},
        stackArn: '',
        stackArtifact: options.stack,
    }));
});
test('diff can diff multiple stacks', async () => {
    // GIVEN
    const buffer = new StringWritable();
    // WHEN
    const exitCode = await toolkit.diff({
        stackNames: ['B'],
        stream: buffer,
    });
    // THEN
    const plainTextOutput = buffer.data.replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '');
    expect(plainTextOutput).toContain('Stack A');
    expect(plainTextOutput).toContain('Stack B');
    expect(exitCode).toBe(0);
});
test('exits with 1 with diffs and fail set to true', async () => {
    // GIVEN
    const buffer = new StringWritable();
    // WHEN
    const exitCode = await toolkit.diff({
        stackNames: ['A'],
        stream: buffer,
        fail: true,
    });
    // THEN
    expect(exitCode).toBe(1);
});
test('throws an error if no valid stack names given', async () => {
    const buffer = new StringWritable();
    // WHEN
    await expect(() => toolkit.diff({
        stackNames: ['X', 'Y', 'Z'],
        stream: buffer,
    })).rejects.toThrow('No stacks match the name(s) X,Y,Z');
});
test('exits with 1 with diff in first stack, but not in second stack and fail set to true', async () => {
    // GIVEN
    const buffer = new StringWritable();
    // WHEN
    const exitCode = await toolkit.diff({
        stackNames: ['A', 'D'],
        stream: buffer,
        fail: true,
    });
    // THEN
    expect(exitCode).toBe(1);
});
test('throws an error during diffs on stack with error metadata', async () => {
    const buffer = new StringWritable();
    // WHEN
    await expect(() => toolkit.diff({
        stackNames: ['C'],
        stream: buffer,
    })).rejects.toThrow(/Found errors/);
});
class StringWritable extends stream_1.Writable {
    constructor(options = {}) {
        super(options);
        this._decoder = new string_decoder_1.StringDecoder(options && options.defaultEncoding);
        this.data = '';
    }
    _write(chunk, encoding, callback) {
        if (encoding === 'buffer') {
            chunk = this._decoder.write(chunk);
        }
        this.data += chunk;
        callback();
    }
    _final(callback) {
        this.data += this._decoder.end();
        callback();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlmZi50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGlmZi50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsbUNBQWtDO0FBQ2xDLG1EQUFrRTtBQUNsRSwyREFBMkQ7QUFFM0Qsc0ZBQWtGO0FBQ2xGLG9EQUFnRDtBQUNoRCxpQ0FBK0Q7QUFFL0QsSUFBSSxlQUFvQyxDQUFDO0FBQ3pDLElBQUksY0FBc0QsQ0FBQztBQUMzRCxJQUFJLE9BQW1CLENBQUM7QUFDeEIsVUFBVSxDQUFDLEdBQUcsRUFBRTtJQUNkLGVBQWUsR0FBRyxJQUFJLDBCQUFtQixDQUFDO1FBQ3hDLE1BQU0sRUFBRSxDQUFDO2dCQUNQLFNBQVMsRUFBRSxHQUFHO2dCQUNkLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUU7YUFDNUI7WUFDRDtnQkFDRSxTQUFTLEVBQUUsR0FBRztnQkFDZCxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUM7Z0JBQ2QsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRTthQUM1QjtZQUNEO2dCQUNFLFNBQVMsRUFBRSxHQUFHO2dCQUNkLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQztnQkFDZCxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFO2dCQUMzQixRQUFRLEVBQUU7b0JBQ1IsV0FBVyxFQUFFO3dCQUNYOzRCQUNFLElBQUksRUFBRSxRQUFRLENBQUMseUJBQXlCLENBQUMsS0FBSzs0QkFDOUMsSUFBSSxFQUFFLGtCQUFrQjt5QkFDekI7cUJBQ0Y7aUJBQ0Y7YUFDRjtZQUNEO2dCQUNFLFNBQVMsRUFBRSxHQUFHO2dCQUNkLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUU7YUFDNUIsQ0FBQztLQUNILENBQUMsQ0FBQztJQUVILGNBQWMsR0FBRyx1QkFBZ0IsQ0FBQyxzREFBeUIsQ0FBQyxDQUFDO0lBRTdELE9BQU8sR0FBRyxJQUFJLHdCQUFVLENBQUM7UUFDdkIs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QyxRQUF3QztRQUNwRCxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDakMsUUFBUSxFQUFFLENBQUM7SUFDYixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXcml0YWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgeyBOb2RlU3RyaW5nRGVjb2RlciwgU3RyaW5nRGVjb2RlciB9IGZyb20gJ3N0cmluZ19kZWNvZGVyJztcbmltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25EZXBsb3ltZW50cyB9IGZyb20gJy4uL2xpYi9hcGkvY2xvdWRmb3JtYXRpb24tZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgQ2RrVG9vbGtpdCB9IGZyb20gJy4uL2xpYi9jZGstdG9vbGtpdCc7XG5pbXBvcnQgeyBpbnN0YW5jZU1vY2tGcm9tLCBNb2NrQ2xvdWRFeGVjdXRhYmxlIH0gZnJvbSAnLi91dGlsJztcblxubGV0IGNsb3VkRXhlY3V0YWJsZTogTW9ja0Nsb3VkRXhlY3V0YWJsZTtcbmxldCBjbG91ZEZvcm1hdGlvbjogamVzdC5Nb2NrZWQ8Q2xvdWRGb3JtYXRpb25EZXBsb3ltZW50cz47XG5sZXQgdG9vbGtpdDogQ2RrVG9vbGtpdDtcbmJlZm9yZUVhY2goKCkgPT4ge1xuICBjbG91ZEV4ZWN1dGFibGUgPSBuZXcgTW9ja0Nsb3VkRXhlY3V0YWJsZSh7XG4gICAgc3RhY2tzOiBbe1xuICAgICAgc3RhY2tOYW1lOiAnQScsXG4gICAgICB0ZW1wbGF0ZTogeyByZXNvdXJjZTogJ0EnIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBzdGFja05hbWU6ICdCJyxcbiAgICAgIGRlcGVuZHM6IFsnQSddLFxuICAgICAgdGVtcGxhdGU6IHsgcmVzb3VyY2U6ICdCJyB9LFxuICAgIH0sXG4gICAge1xuICAgICAgc3RhY2tOYW1lOiAnQycsXG4gICAgICBkZXBlbmRzOiBbJ0EnXSxcbiAgICAgIHRlbXBsYXRlOiB7IHJlc291cmNlOiAnQycgfSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICcvcmVzb3VyY2UnOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogY3hzY2hlbWEuQXJ0aWZhY3RNZXRhZGF0YUVudHJ5VHlwZS5FUlJPUixcbiAgICAgICAgICAgIGRhdGE6ICd0aGlzIGlzIGFuIGVycm9yJyxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHN0YWNrTmFtZTogJ0QnLFxuICAgICAgdGVtcGxhdGU6IHsgcmVzb3VyY2U6ICdEJyB9LFxuICAgIH1dLFxuICB9KTtcblxuICBjbG91ZEZvcm1hdGlvbiA9IGluc3RhbmNlTW9ja0Zyb20oQ2xvdWRGb3JtYXRpb25EZXBsb3ltZW50cyk7XG5cbiAgdG9vbGtpdCA9IG5ldyBDZGtUb29sa2l0KHtcbiAgICBjbG91ZEV4ZWN1dGFibGUsXG4gICAgY2xvdWRGb3JtYXRpb24sXG4gICAgY29uZmlndXJhdGlvbjogY2xvdWRFeGVjdXRhYmxlLmNvbmZpZ3VyYXRpb24sXG4gICAgc2RrUHJvdmlkZXI6IGNsb3VkRXhlY3V0YWJsZS5zZGtQcm92aWRlcixcbiAgfSk7XG5cbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbnNcbiAgY2xvdWRGb3JtYXRpb24ucmVhZEN1cnJlbnRUZW1wbGF0ZS5tb2NrSW1wbGVtZW50YXRpb24oKHN0YWNrQXJ0aWZhY3Q6IENsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCkgPT4ge1xuICAgIGlmIChzdGFja0FydGlmYWN0LnN0YWNrTmFtZSA9PT0gJ0QnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcmVzb3VyY2U6ICdEJyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gIH0pO1xuICBjbG91ZEZvcm1hdGlvbi5kZXBsb3lTdGFjay5tb2NrSW1wbGVtZW50YXRpb24oKG9wdGlvbnMpID0+IFByb21pc2UucmVzb2x2ZSh7XG4gICAgbm9PcDogdHJ1ZSxcbiAgICBvdXRwdXRzOiB7fSxcbiAgICBzdGFja0FybjogJycsXG4gICAgc3RhY2tBcnRpZmFjdDogb3B0aW9ucy5zdGFjayxcbiAgfSkpO1xufSk7XG5cbnRlc3QoJ2RpZmYgY2FuIGRpZmYgbXVsdGlwbGUgc3RhY2tzJywgYXN5bmMgKCkgPT4ge1xuICAvLyBHSVZFTlxuICBjb25zdCBidWZmZXIgPSBuZXcgU3RyaW5nV3JpdGFibGUoKTtcblxuICAvLyBXSEVOXG4gIGNvbnN0IGV4aXRDb2RlID0gYXdhaXQgdG9vbGtpdC5kaWZmKHtcbiAgICBzdGFja05hbWVzOiBbJ0InXSxcbiAgICBzdHJlYW06IGJ1ZmZlcixcbiAgfSk7XG5cbiAgLy8gVEhFTlxuICBjb25zdCBwbGFpblRleHRPdXRwdXQgPSBidWZmZXIuZGF0YS5yZXBsYWNlKC9cXHgxQlxcW1swLT9dKlsgLS9dKltALX5dL2csICcnKTtcbiAgZXhwZWN0KHBsYWluVGV4dE91dHB1dCkudG9Db250YWluKCdTdGFjayBBJyk7XG4gIGV4cGVjdChwbGFpblRleHRPdXRwdXQpLnRvQ29udGFpbignU3RhY2sgQicpO1xuXG4gIGV4cGVjdChleGl0Q29kZSkudG9CZSgwKTtcbn0pO1xuXG50ZXN0KCdleGl0cyB3aXRoIDEgd2l0aCBkaWZmcyBhbmQgZmFpbCBzZXQgdG8gdHJ1ZScsIGFzeW5jICgpID0+IHtcbiAgLy8gR0lWRU5cbiAgY29uc3QgYnVmZmVyID0gbmV3IFN0cmluZ1dyaXRhYmxlKCk7XG5cbiAgLy8gV0hFTlxuICBjb25zdCBleGl0Q29kZSA9IGF3YWl0IHRvb2xraXQuZGlmZih7XG4gICAgc3RhY2tOYW1lczogWydBJ10sXG4gICAgc3RyZWFtOiBidWZmZXIsXG4gICAgZmFpbDogdHJ1ZSxcbiAgfSk7XG5cbiAgLy8gVEhFTlxuICBleHBlY3QoZXhpdENvZGUpLnRvQmUoMSk7XG59KTtcblxudGVzdCgndGhyb3dzIGFuIGVycm9yIGlmIG5vIHZhbGlkIHN0YWNrIG5hbWVzIGdpdmVuJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBidWZmZXIgPSBuZXcgU3RyaW5nV3JpdGFibGUoKTtcblxuICAvLyBXSEVOXG4gIGF3YWl0IGV4cGVjdCgoKSA9PiB0b29sa2l0LmRpZmYoe1xuICAgIHN0YWNrTmFtZXM6IFsnWCcsICdZJywgJ1onXSxcbiAgICBzdHJlYW06IGJ1ZmZlcixcbiAgfSkpLnJlamVjdHMudG9UaHJvdygnTm8gc3RhY2tzIG1hdGNoIHRoZSBuYW1lKHMpIFgsWSxaJyk7XG59KTtcblxudGVzdCgnZXhpdHMgd2l0aCAxIHdpdGggZGlmZiBpbiBmaXJzdCBzdGFjaywgYnV0IG5vdCBpbiBzZWNvbmQgc3RhY2sgYW5kIGZhaWwgc2V0IHRvIHRydWUnLCBhc3luYyAoKSA9PiB7XG4gIC8vIEdJVkVOXG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBTdHJpbmdXcml0YWJsZSgpO1xuXG4gIC8vIFdIRU5cbiAgY29uc3QgZXhpdENvZGUgPSBhd2FpdCB0b29sa2l0LmRpZmYoe1xuICAgIHN0YWNrTmFtZXM6IFsnQScsICdEJ10sXG4gICAgc3RyZWFtOiBidWZmZXIsXG4gICAgZmFpbDogdHJ1ZSxcbiAgfSk7XG5cbiAgLy8gVEhFTlxuICBleHBlY3QoZXhpdENvZGUpLnRvQmUoMSk7XG59KTtcblxudGVzdCgndGhyb3dzIGFuIGVycm9yIGR1cmluZyBkaWZmcyBvbiBzdGFjayB3aXRoIGVycm9yIG1ldGFkYXRhJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBidWZmZXIgPSBuZXcgU3RyaW5nV3JpdGFibGUoKTtcblxuICAvLyBXSEVOXG4gIGF3YWl0IGV4cGVjdCgoKSA9PiB0b29sa2l0LmRpZmYoe1xuICAgIHN0YWNrTmFtZXM6IFsnQyddLFxuICAgIHN0cmVhbTogYnVmZmVyLFxuICB9KSkucmVqZWN0cy50b1Rocm93KC9Gb3VuZCBlcnJvcnMvKTtcbn0pO1xuXG5jbGFzcyBTdHJpbmdXcml0YWJsZSBleHRlbmRzIFdyaXRhYmxlIHtcbiAgcHVibGljIGRhdGE6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBfZGVjb2RlcjogTm9kZVN0cmluZ0RlY29kZXI7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogYW55ID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucyAmJiBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyk7XG4gICAgdGhpcy5kYXRhID0gJyc7XG4gIH1cblxuICBwdWJsaWMgX3dyaXRlKGNodW5rOiBhbnksIGVuY29kaW5nOiBzdHJpbmcsIGNhbGxiYWNrOiAoZXJyb3I/OiBFcnJvciB8IHVuZGVmaW5lZCkgPT4gdm9pZCkge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIGNodW5rID0gdGhpcy5fZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuZGF0YSArPSBjaHVuaztcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcHVibGljIF9maW5hbChjYWxsYmFjazogKGVycm9yPzogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5kYXRhICs9IHRoaXMuX2RlY29kZXIuZW5kKCk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuIl19