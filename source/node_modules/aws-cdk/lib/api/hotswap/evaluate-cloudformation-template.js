"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvaluateCloudFormationTemplate = exports.CfnEvaluationException = void 0;
class CfnEvaluationException extends Error {
}
exports.CfnEvaluationException = CfnEvaluationException;
class EvaluateCloudFormationTemplate {
    constructor(props) {
        this.stackResources = props.listStackResources;
        this.template = props.stackArtifact.template;
        this.context = {
            'AWS::AccountId': props.account,
            'AWS::Region': props.region,
            'AWS::Partition': props.partition,
            'AWS::URLSuffix': props.urlSuffix,
            ...props.parameters,
        };
        this.account = props.account;
        this.region = props.region;
        this.partition = props.partition;
    }
    async findPhysicalNameFor(logicalId) {
        var _a;
        const stackResources = await this.stackResources.listStackResources();
        return (_a = stackResources.find(sr => sr.LogicalResourceId === logicalId)) === null || _a === void 0 ? void 0 : _a.PhysicalResourceId;
    }
    findReferencesTo(logicalId) {
        var _a, _b;
        const ret = new Array();
        for (const [resourceLogicalId, resourceDef] of Object.entries((_b = (_a = this.template) === null || _a === void 0 ? void 0 : _a.Resources) !== null && _b !== void 0 ? _b : {})) {
            if (logicalId !== resourceLogicalId && this.references(logicalId, resourceDef)) {
                ret.push({
                    ...resourceDef,
                    LogicalId: resourceLogicalId,
                });
            }
        }
        return ret;
    }
    async evaluateCfnExpression(cfnExpression) {
        const self = this;
        class CfnIntrinsics {
            evaluateIntrinsic(intrinsic) {
                const intrinsicFunc = this[intrinsic.name];
                if (!intrinsicFunc) {
                    throw new CfnEvaluationException(`CloudFormation function ${intrinsic.name} is not supported`);
                }
                const argsAsArray = Array.isArray(intrinsic.args) ? intrinsic.args : [intrinsic.args];
                return intrinsicFunc.apply(this, argsAsArray);
            }
            async 'Fn::Join'(separator, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs.join(separator);
            }
            async 'Fn::Split'(separator, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs.split(separator);
            }
            async 'Fn::Select'(index, args) {
                const evaluatedArgs = await self.evaluateCfnExpression(args);
                return evaluatedArgs[index];
            }
            async 'Ref'(logicalId) {
                const refTarget = await self.findRefTarget(logicalId);
                if (refTarget) {
                    return refTarget;
                }
                else {
                    throw new CfnEvaluationException(`Parameter or resource '${logicalId}' could not be found for evaluation`);
                }
            }
            async 'Fn::GetAtt'(logicalId, attributeName) {
                // ToDo handle the 'logicalId.attributeName' form of Fn::GetAtt
                const attrValue = await self.findGetAttTarget(logicalId, attributeName);
                if (attrValue) {
                    return attrValue;
                }
                else {
                    throw new CfnEvaluationException(`Attribute '${attributeName}' of resource '${logicalId}' could not be found for evaluation`);
                }
            }
            async 'Fn::Sub'(template, explicitPlaceholders) {
                const placeholders = explicitPlaceholders
                    ? await self.evaluateCfnExpression(explicitPlaceholders)
                    : {};
                return asyncGlobalReplace(template, /\${([^}]*)}/g, key => {
                    if (key in placeholders) {
                        return placeholders[key];
                    }
                    else {
                        const splitKey = key.split('.');
                        return splitKey.length === 1
                            ? this.Ref(key)
                            : this['Fn::GetAtt'](splitKey[0], splitKey.slice(1).join('.'));
                    }
                });
            }
        }
        if (cfnExpression == null) {
            return cfnExpression;
        }
        if (Array.isArray(cfnExpression)) {
            return Promise.all(cfnExpression.map(expr => this.evaluateCfnExpression(expr)));
        }
        if (typeof cfnExpression === 'object') {
            const intrinsic = this.parseIntrinsic(cfnExpression);
            if (intrinsic) {
                return new CfnIntrinsics().evaluateIntrinsic(intrinsic);
            }
            else {
                const ret = {};
                for (const [key, val] of Object.entries(cfnExpression)) {
                    ret[key] = await this.evaluateCfnExpression(val);
                }
                return ret;
            }
        }
        return cfnExpression;
    }
    references(logicalId, templateElement) {
        if (typeof templateElement === 'string') {
            return logicalId === templateElement;
        }
        if (templateElement == null) {
            return false;
        }
        if (Array.isArray(templateElement)) {
            return templateElement.some(el => this.references(logicalId, el));
        }
        if (typeof templateElement === 'object') {
            return Object.values(templateElement).some(el => this.references(logicalId, el));
        }
        return false;
    }
    parseIntrinsic(x) {
        const keys = Object.keys(x);
        if (keys.length === 1 && (keys[0].startsWith('Fn::') || keys[0] === 'Ref')) {
            return {
                name: keys[0],
                args: x[keys[0]],
            };
        }
        return undefined;
    }
    async findRefTarget(logicalId) {
        // first, check to see if the Ref is a Parameter who's value we have
        const parameterTarget = this.context[logicalId];
        if (parameterTarget) {
            return parameterTarget;
        }
        // if it's not a Parameter, we need to search in the current Stack resources
        return this.findGetAttTarget(logicalId);
    }
    async findGetAttTarget(logicalId, attribute) {
        const stackResources = await this.stackResources.listStackResources();
        const foundResource = stackResources.find(sr => sr.LogicalResourceId === logicalId);
        if (!foundResource) {
            return undefined;
        }
        // now, we need to format the appropriate identifier depending on the resource type,
        // and the requested attribute name
        return this.formatResourceAttribute(foundResource, attribute);
    }
    formatResourceAttribute(resource, attribute) {
        const physicalId = resource.PhysicalResourceId;
        // no attribute means Ref expression, for which we use the physical ID directly
        if (!attribute) {
            return physicalId;
        }
        const resourceTypeFormats = RESOURCE_TYPE_ATTRIBUTES_FORMATS[resource.ResourceType];
        if (!resourceTypeFormats) {
            throw new CfnEvaluationException(`We don't support attributes of the '${resource.ResourceType}' resource. This is a CDK limitation. ` +
                'Please report it at https://github.com/aws/aws-cdk/issues/new/choose');
        }
        const attributeFmtFunc = resourceTypeFormats[attribute];
        if (!attributeFmtFunc) {
            throw new CfnEvaluationException(`We don't support the '${attribute}' attribute of the '${resource.ResourceType}' resource. This is a CDK limitation. ` +
                'Please report it at https://github.com/aws/aws-cdk/issues/new/choose');
        }
        const service = this.getServiceOfResource(resource);
        const resourceTypeArnPart = this.getResourceTypeArnPartOfResource(resource);
        return attributeFmtFunc({
            partition: this.partition,
            service,
            region: this.region,
            account: this.account,
            resourceType: resourceTypeArnPart,
            resourceName: physicalId,
        });
    }
    getServiceOfResource(resource) {
        return resource.ResourceType.split('::')[1].toLowerCase();
    }
    getResourceTypeArnPartOfResource(resource) {
        return resource.ResourceType.split('::')[2].toLowerCase();
    }
}
exports.EvaluateCloudFormationTemplate = EvaluateCloudFormationTemplate;
const RESOURCE_TYPE_ATTRIBUTES_FORMATS = {
    'AWS::IAM::Role': { Arn: iamArnFmt },
    'AWS::IAM::User': { Arn: iamArnFmt },
    'AWS::IAM::Group': { Arn: iamArnFmt },
    'AWS::S3::Bucket': { Arn: s3ArnFmt },
    'AWS::Lambda::Function': { Arn: stdColonResourceArnFmt },
};
function iamArnFmt(parts) {
    // we skip region for IAM resources
    return `arn:${parts.partition}:${parts.service}::${parts.account}:${parts.resourceType}/${parts.resourceName}`;
}
function s3ArnFmt(parts) {
    // we skip account, region and resourceType for S3 resources
    return `arn:${parts.partition}:${parts.service}:::${parts.resourceName}`;
}
function stdColonResourceArnFmt(parts) {
    // this is a standard format for ARNs like: arn:aws:service:region:account:resourceType:resourceName
    return `arn:${parts.partition}:${parts.service}:${parts.region}:${parts.account}:${parts.resourceType}:${parts.resourceName}`;
}
async function asyncGlobalReplace(str, regex, cb) {
    if (!regex.global) {
        throw new Error('Regex must be created with /g flag');
    }
    const ret = new Array();
    let start = 0;
    while (true) {
        const match = regex.exec(str);
        if (!match) {
            break;
        }
        ret.push(str.substring(start, match.index));
        ret.push(await cb(match[1]));
        start = regex.lastIndex;
    }
    ret.push(str.substr(start));
    return ret.join('');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFJQSxNQUFhLHNCQUF1QixTQUFRLEtBQUs7Q0FBRztBQUFwRCx3REFBb0Q7QUFrQnBELE1BQWEsOEJBQThCO0lBUXpDLFlBQVksS0FBMEM7UUFDcEQsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUMsa0JBQWtCLENBQUM7UUFDL0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQztRQUM3QyxJQUFJLENBQUMsT0FBTyxHQUFHO1lBQ2IsZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLE9BQU87WUFDL0IsYUFBYSxFQUFFLEtBQUssQ0FBQyxNQUFNO1lBQzNCLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxTQUFTO1lBQ2pDLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxTQUFTO1lBQ2pDLEdBQUcsS0FBSyxDQUFDLFVBQVU7U0FDcEIsQ0FBQztRQUNGLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztRQUM3QixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7UUFDM0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO0lBQ25DLENBQUM7SUFFTSxLQUFLLENBQUMsbUJBQW1CLENBQUMsU0FBaUI7O1FBQ2hELE1BQU0sY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ3RFLGFBQU8sY0FBYyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsS0FBSyxTQUFTLENBQUMsMENBQUUsa0JBQWtCLENBQUM7SUFDM0YsQ0FBQztJQUVNLGdCQUFnQixDQUFD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WSxFQUFFLENBQUM7QUFDaEksQ0FBQztBQU9ELEtBQUssVUFBVSxrQkFBa0IsQ0FBQyxHQUFXLEVBQUUsS0FBYSxFQUFFLEVBQWtDO0lBQzlGLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO0tBQUU7SUFFN0UsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztJQUNoQyxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxPQUFPLElBQUksRUFBRTtRQUNYLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUFFLE1BQU07U0FBRTtRQUV0QixHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzVDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU3QixLQUFLLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztLQUN6QjtJQUNELEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBRTVCLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN0QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IExpc3RTdGFja1Jlc291cmNlcyB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGNsYXNzIENmbkV2YWx1YXRpb25FeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc291cmNlRGVmaW5pdGlvbiB7XG4gIHJlYWRvbmx5IExvZ2ljYWxJZDogc3RyaW5nO1xuICByZWFkb25seSBUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IFByb3BlcnRpZXM6IHsgW3A6IHN0cmluZ106IGFueSB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZVByb3BzIHtcbiAgcmVhZG9ubHkgc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuICByZWFkb25seSBwYXJhbWV0ZXJzOiB7IFtwYXJhbWV0ZXJOYW1lOiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgcmVhZG9ubHkgYWNjb3VudDogc3RyaW5nO1xuICByZWFkb25seSByZWdpb246IHN0cmluZztcbiAgcmVhZG9ubHkgcGFydGl0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHVybFN1ZmZpeDogc3RyaW5nO1xuICByZWFkb25seSBsaXN0U3RhY2tSZXNvdXJjZXM6IExpc3RTdGFja1Jlc291cmNlcztcbn1cblxuZXhwb3J0IGNsYXNzIEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2tSZXNvdXJjZXM6IExpc3RTdGFja1Jlc291cmNlcztcbiAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZTogeyBbc2VjdGlvbjogc3RyaW5nXTogeyBbaGVhZGluZ3M6IHN0cmluZ106IGFueSB9IH07XG4gIHByaXZhdGUgcmVhZG9ubHkgY29udGV4dDogeyBbazogc3RyaW5nXTogc3RyaW5nIH07XG4gIHByaXZhdGUgcmVhZG9ubHkgYWNjb3VudDogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHJlZ2lvbjogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHBhcnRpdGlvbjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGVQcm9wcykge1xuICAgIHRoaXMuc3RhY2tSZXNvdXJjZXMgPSBwcm9wcy5saXN0U3RhY2tSZXNvdXJjZXM7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IHByb3BzLnN0YWNrQXJ0aWZhY3QudGVtcGxhdGU7XG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgJ0FXUzo6QWNjb3VudElkJzogcHJvcHMuYWNjb3VudCxcbiAgICAgICdBV1M6OlJlZ2lvbic6IHByb3BzLnJlZ2lvbixcbiAgICAgICdBV1M6OlBhcnRpdGlvbic6IHByb3BzLnBhcnRpdGlvbixcbiAgICAgICdBV1M6OlVSTFN1ZmZpeCc6IHByb3BzLnVybFN1ZmZpeCxcbiAgICAgIC4uLnByb3BzLnBhcmFtZXRlcnMsXG4gICAgfTtcbiAgICB0aGlzLmFjY291bnQgPSBwcm9wcy5hY2NvdW50O1xuICAgIHRoaXMucmVnaW9uID0gcHJvcHMucmVnaW9uO1xuICAgIHRoaXMucGFydGl0aW9uID0gcHJvcHMucGFydGl0aW9uO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGZpbmRQaHlzaWNhbE5hbWVGb3IobG9naWNhbElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHN0YWNrUmVzb3VyY2VzID0gYXdhaXQgdGhpcy5zdGFja1Jlc291cmNlcy5saXN0U3RhY2tSZXNvdXJjZXMoKTtcbiAgICByZXR1cm4gc3RhY2tSZXNvdXJjZXMuZmluZChzciA9PiBzci5Mb2dpY2FsUmVzb3VyY2VJZCA9PT0gbG9naWNhbElkKT8uUGh5c2ljYWxSZXNvdXJjZUlkO1xuICB9XG5cbiAgcHVibGljIGZpbmRSZWZlcmVuY2VzVG8obG9naWNhbElkOiBzdHJpbmcpOiBBcnJheTxSZXNvdXJjZURlZmluaXRpb24+IHtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXk8UmVzb3VyY2VEZWZpbml0aW9uPigpO1xuICAgIGZvciAoY29uc3QgW3Jlc291cmNlTG9naWNhbElkLCByZXNvdXJjZURlZl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy50ZW1wbGF0ZT8uUmVzb3VyY2VzID8/IHt9KSkge1xuICAgICAgaWYgKGxvZ2ljYWxJZCAhPT0gcmVzb3VyY2VMb2dpY2FsSWQgJiYgdGhpcy5yZWZlcmVuY2VzKGxvZ2ljYWxJZCwgcmVzb3VyY2VEZWYpKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAuLi4ocmVzb3VyY2VEZWYgYXMgYW55KSxcbiAgICAgICAgICBMb2dpY2FsSWQ6IHJlc291cmNlTG9naWNhbElkLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBldmFsdWF0ZUNmbkV4cHJlc3Npb24oY2ZuRXhwcmVzc2lvbjogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjbGFzcyBDZm5JbnRyaW5zaWNzIHtcbiAgICAgIHB1YmxpYyBldmFsdWF0ZUludHJpbnNpYyhpbnRyaW5zaWM6IEludHJpbnNpYyk6IGFueSB7XG4gICAgICAgIGNvbnN0IGludHJpbnNpY0Z1bmMgPSAodGhpcyBhcyBhbnkpW2ludHJpbnNpYy5uYW1lXTtcbiAgICAgICAgaWYgKCFpbnRyaW5zaWNGdW5jKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYENsb3VkRm9ybWF0aW9uIGZ1bmN0aW9uICR7aW50cmluc2ljLm5hbWV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFyZ3NBc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbnRyaW5zaWMuYXJncykgPyBpbnRyaW5zaWMuYXJncyA6IFtpbnRyaW5zaWMuYXJnc107XG5cbiAgICAgICAgcmV0dXJuIGludHJpbnNpY0Z1bmMuYXBwbHkodGhpcywgYXJnc0FzQXJyYXkpO1xuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OkpvaW4nKHNlcGFyYXRvcjogc3RyaW5nLCBhcmdzOiBhbnlbXSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGV2YWx1YXRlZEFyZ3MgPSBhd2FpdCBzZWxmLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihhcmdzKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZEFyZ3Muam9pbihzZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OlNwbGl0JyhzZXBhcmF0b3I6IHN0cmluZywgYXJnczogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgZXZhbHVhdGVkQXJncyA9IGF3YWl0IHNlbGYuZXZhbHVhdGVDZm5FeHByZXNzaW9uKGFyZ3MpO1xuICAgICAgICByZXR1cm4gZXZhbHVhdGVkQXJncy5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OlNlbGVjdCcoaW5kZXg6IG51bWJlciwgYXJnczogYW55W10pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCBldmFsdWF0ZWRBcmdzID0gYXdhaXQgc2VsZi5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oYXJncyk7XG4gICAgICAgIHJldHVybiBldmFsdWF0ZWRBcmdzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ1JlZicobG9naWNhbElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCByZWZUYXJnZXQgPSBhd2FpdCBzZWxmLmZpbmRSZWZUYXJnZXQobG9naWNhbElkKTtcbiAgICAgICAgaWYgKHJlZlRhcmdldCkge1xuICAgICAgICAgIHJldHVybiByZWZUYXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYFBhcmFtZXRlciBvciByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyBjb3VsZCBub3QgYmUgZm91bmQgZm9yIGV2YWx1YXRpb25gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhc3luYyAnRm46OkdldEF0dCcobG9naWNhbElkOiBzdHJpbmcsIGF0dHJpYnV0ZU5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIC8vIFRvRG8gaGFuZGxlIHRoZSAnbG9naWNhbElkLmF0dHJpYnV0ZU5hbWUnIGZvcm0gb2YgRm46OkdldEF0dFxuICAgICAgICBjb25zdCBhdHRyVmFsdWUgPSBhd2FpdCBzZWxmLmZpbmRHZXRBdHRUYXJnZXQobG9naWNhbElkLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgaWYgKGF0dHJWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBhdHRyVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYEF0dHJpYnV0ZSAnJHthdHRyaWJ1dGVOYW1lfScgb2YgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgY291bGQgbm90IGJlIGZvdW5kIGZvciBldmFsdWF0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXN5bmMgJ0ZuOjpTdWInKHRlbXBsYXRlOiBzdHJpbmcsIGV4cGxpY2l0UGxhY2Vob2xkZXJzPzogeyBbdmFyaWFibGU6IHN0cmluZ106IHN0cmluZyB9KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJzID0gZXhwbGljaXRQbGFjZWhvbGRlcnNcbiAgICAgICAgICA/IGF3YWl0IHNlbGYuZXZhbHVhdGVDZm5FeHByZXNzaW9uKGV4cGxpY2l0UGxhY2Vob2xkZXJzKVxuICAgICAgICAgIDoge307XG5cbiAgICAgICAgcmV0dXJuIGFzeW5jR2xvYmFsUmVwbGFjZSh0ZW1wbGF0ZSwgL1xcJHsoW159XSopfS9nLCBrZXkgPT4ge1xuICAgICAgICAgIGlmIChrZXkgaW4gcGxhY2Vob2xkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXJzW2tleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0S2V5ID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICByZXR1cm4gc3BsaXRLZXkubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgID8gdGhpcy5SZWYoa2V5KVxuICAgICAgICAgICAgICA6IHRoaXNbJ0ZuOjpHZXRBdHQnXShzcGxpdEtleVswXSwgc3BsaXRLZXkuc2xpY2UoMSkuam9pbignLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjZm5FeHByZXNzaW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjZm5FeHByZXNzaW9uO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNmbkV4cHJlc3Npb24pKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2ZuRXhwcmVzc2lvbi5tYXAoZXhwciA9PiB0aGlzLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihleHByKSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2ZuRXhwcmVzc2lvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGludHJpbnNpYyA9IHRoaXMucGFyc2VJbnRyaW5zaWMoY2ZuRXhwcmVzc2lvbik7XG4gICAgICBpZiAoaW50cmluc2ljKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2ZuSW50cmluc2ljcygpLmV2YWx1YXRlSW50cmluc2ljKGludHJpbnNpYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGNmbkV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBhd2FpdCB0aGlzLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNmbkV4cHJlc3Npb247XG4gIH1cblxuICBwcml2YXRlIHJlZmVyZW5jZXMobG9naWNhbElkOiBzdHJpbmcsIHRlbXBsYXRlRWxlbWVudDogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZUVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbG9naWNhbElkID09PSB0ZW1wbGF0ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKHRlbXBsYXRlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGVtcGxhdGVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlRWxlbWVudC5zb21lKGVsID0+IHRoaXMucmVmZXJlbmNlcyhsb2dpY2FsSWQsIGVsKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZUVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0ZW1wbGF0ZUVsZW1lbnQpLnNvbWUoZWwgPT4gdGhpcy5yZWZlcmVuY2VzKGxvZ2ljYWxJZCwgZWwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIHBhcnNlSW50cmluc2ljKHg6IGFueSk6IEludHJpbnNpYyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiAoa2V5c1swXS5zdGFydHNXaXRoKCdGbjo6JykgfHwga2V5c1swXSA9PT0gJ1JlZicpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBrZXlzWzBdLFxuICAgICAgICBhcmdzOiB4W2tleXNbMF1dLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmluZFJlZlRhcmdldChsb2dpY2FsSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgLy8gZmlyc3QsIGNoZWNrIHRvIHNlZSBpZiB0aGUgUmVmIGlzIGEgUGFyYW1ldGVyIHdobydzIHZhbHVlIHdlIGhhdmVcbiAgICBjb25zdCBwYXJhbWV0ZXJUYXJnZXQgPSB0aGlzLmNvbnRleHRbbG9naWNhbElkXTtcbiAgICBpZiAocGFyYW1ldGVyVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gcGFyYW1ldGVyVGFyZ2V0O1xuICAgIH1cbiAgICAvLyBpZiBpdCdzIG5vdCBhIFBhcmFtZXRlciwgd2UgbmVlZCB0byBzZWFyY2ggaW4gdGhlIGN1cnJlbnQgU3RhY2sgcmVzb3VyY2VzXG4gICAgcmV0dXJuIHRoaXMuZmluZEdldEF0dFRhcmdldChsb2dpY2FsSWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmaW5kR2V0QXR0VGFyZ2V0KGxvZ2ljYWxJZDogc3RyaW5nLCBhdHRyaWJ1dGU/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHN0YWNrUmVzb3VyY2VzID0gYXdhaXQgdGhpcy5zdGFja1Jlc291cmNlcy5saXN0U3RhY2tSZXNvdXJjZXMoKTtcbiAgICBjb25zdCBmb3VuZFJlc291cmNlID0gc3RhY2tSZXNvdXJjZXMuZmluZChzciA9PiBzci5Mb2dpY2FsUmVzb3VyY2VJZCA9PT0gbG9naWNhbElkKTtcbiAgICBpZiAoIWZvdW5kUmVzb3VyY2UpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG5vdywgd2UgbmVlZCB0byBmb3JtYXQgdGhlIGFwcHJvcHJpYXRlIGlkZW50aWZpZXIgZGVwZW5kaW5nIG9uIHRoZSByZXNvdXJjZSB0eXBlLFxuICAgIC8vIGFuZCB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZSBuYW1lXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzb3VyY2VBdHRyaWJ1dGUoZm91bmRSZXNvdXJjZSwgYXR0cmlidXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0UmVzb3VyY2VBdHRyaWJ1dGUocmVzb3VyY2U6IEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeSwgYXR0cmlidXRlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHBoeXNpY2FsSWQgPSByZXNvdXJjZS5QaHlzaWNhbFJlc291cmNlSWQ7XG5cbiAgICAvLyBubyBhdHRyaWJ1dGUgbWVhbnMgUmVmIGV4cHJlc3Npb24sIGZvciB3aGljaCB3ZSB1c2UgdGhlIHBoeXNpY2FsIElEIGRpcmVjdGx5XG4gICAgaWYgKCFhdHRyaWJ1dGUpIHtcbiAgICAgIHJldHVybiBwaHlzaWNhbElkO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc291cmNlVHlwZUZvcm1hdHMgPSBSRVNPVVJDRV9UWVBFX0FUVFJJQlVURVNfRk9STUFUU1tyZXNvdXJjZS5SZXNvdXJjZVR5cGVdO1xuICAgIGlmICghcmVzb3VyY2VUeXBlRm9ybWF0cykge1xuICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYFdlIGRvbid0IHN1cHBvcnQgYXR0cmlidXRlcyBvZiB0aGUgJyR7cmVzb3VyY2UuUmVzb3VyY2VUeXBlfScgcmVzb3VyY2UuIFRoaXMgaXMgYSBDREsgbGltaXRhdGlvbi4gYCArXG4gICAgICAgICdQbGVhc2UgcmVwb3J0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvbmV3L2Nob29zZScpO1xuICAgIH1cbiAgICBjb25zdCBhdHRyaWJ1dGVGbXRGdW5jID0gcmVzb3VyY2VUeXBlRm9ybWF0c1thdHRyaWJ1dGVdO1xuICAgIGlmICghYXR0cmlidXRlRm10RnVuYykge1xuICAgICAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYFdlIGRvbid0IHN1cHBvcnQgdGhlICcke2F0dHJpYnV0ZX0nIGF0dHJpYnV0ZSBvZiB0aGUgJyR7cmVzb3VyY2UuUmVzb3VyY2VUeXBlfScgcmVzb3VyY2UuIFRoaXMgaXMgYSBDREsgbGltaXRhdGlvbi4gYCArXG4gICAgICAgICdQbGVhc2UgcmVwb3J0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvbmV3L2Nob29zZScpO1xuICAgIH1cbiAgICBjb25zdCBzZXJ2aWNlID0gdGhpcy5nZXRTZXJ2aWNlT2ZSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgY29uc3QgcmVzb3VyY2VUeXBlQXJuUGFydCA9IHRoaXMuZ2V0UmVzb3VyY2VUeXBlQXJuUGFydE9mUmVzb3VyY2UocmVzb3VyY2UpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVGbXRGdW5jKHtcbiAgICAgIHBhcnRpdGlvbjogdGhpcy5wYXJ0aXRpb24sXG4gICAgICBzZXJ2aWNlLFxuICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcbiAgICAgIGFjY291bnQ6IHRoaXMuYWNjb3VudCxcbiAgICAgIHJlc291cmNlVHlwZTogcmVzb3VyY2VUeXBlQXJuUGFydCxcbiAgICAgIHJlc291cmNlTmFtZTogcGh5c2ljYWxJZCEsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdldFNlcnZpY2VPZlJlc291cmNlKHJlc291cmNlOiBBV1MuQ2xvdWRGb3JtYXRpb24uU3RhY2tSZXNvdXJjZVN1bW1hcnkpOiBzdHJpbmcge1xuICAgIHJldHVybiByZXNvdXJjZS5SZXNvdXJjZVR5cGUuc3BsaXQoJzo6JylbMV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmVzb3VyY2VUeXBlQXJuUGFydE9mUmVzb3VyY2UocmVzb3VyY2U6IEFXUy5DbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJlc291cmNlLlJlc291cmNlVHlwZS5zcGxpdCgnOjonKVsyXS50b0xvd2VyQ2FzZSgpO1xuICB9XG59XG5cbmludGVyZmFjZSBBcm5QYXJ0cyB7XG4gIHJlYWRvbmx5IHBhcnRpdGlvbjogc3RyaW5nO1xuICByZWFkb25seSBzZXJ2aWNlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlZ2lvbjogc3RyaW5nO1xuICByZWFkb25seSBhY2NvdW50OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlc291cmNlVHlwZTogc3RyaW5nO1xuICByZWFkb25seSByZXNvdXJjZU5hbWU6IHN0cmluZztcbn1cblxuY29uc3QgUkVTT1VSQ0VfVFlQRV9BVFRSSUJVVEVTX0ZPUk1BVFM6IHsgW3R5cGU6IHN0cmluZ106IHsgW2F0dHJpYnV0ZTogc3RyaW5nXTogKHBhcnRzOiBBcm5QYXJ0cykgPT4gc3RyaW5nIH0gfSA9IHtcbiAgJ0FXUzo6SUFNOjpSb2xlJzogeyBBcm46IGlhbUFybkZtdCB9LFxuICAnQVdTOjpJQU06OlVzZXInOiB7IEFybjogaWFtQXJuRm10IH0sXG4gICdBV1M6OklBTTo6R3JvdXAnOiB7IEFybjogaWFtQXJuRm10IH0sXG4gICdBV1M6OlMzOjpCdWNrZXQnOiB7IEFybjogczNBcm5GbXQgfSxcbiAgJ0FXUzo6TGFtYmRhOjpGdW5jdGlvbic6IHsgQXJuOiBzdGRDb2xvblJlc291cmNlQXJuRm10IH0sXG59O1xuXG5mdW5jdGlvbiBpYW1Bcm5GbXQocGFydHM6IEFyblBhcnRzKTogc3RyaW5nIHtcbiAgLy8gd2Ugc2tpcCByZWdpb24gZm9yIElBTSByZXNvdXJjZXNcbiAgcmV0dXJuIGBhcm46JHtwYXJ0cy5wYXJ0aXRpb259OiR7cGFydHMuc2VydmljZX06OiR7cGFydHMuYWNjb3VudH06JHtwYXJ0cy5yZXNvdXJjZVR5cGV9LyR7cGFydHMucmVzb3VyY2VOYW1lfWA7XG59XG5cbmZ1bmN0aW9uIHMzQXJuRm10KHBhcnRzOiBBcm5QYXJ0cyk6IHN0cmluZyB7XG4gIC8vIHdlIHNraXAgYWNjb3VudCwgcmVnaW9uIGFuZCByZXNvdXJjZVR5cGUgZm9yIFMzIHJlc291cmNlc1xuICByZXR1cm4gYGFybjoke3BhcnRzLnBhcnRpdGlvbn06JHtwYXJ0cy5zZXJ2aWNlfTo6OiR7cGFydHMucmVzb3VyY2VOYW1lfWA7XG59XG5cbmZ1bmN0aW9uIHN0ZENvbG9uUmVzb3VyY2VBcm5GbXQocGFydHM6IEFyblBhcnRzKTogc3RyaW5nIHtcbiAgLy8gdGhpcyBpcyBhIHN0YW5kYXJkIGZvcm1hdCBmb3IgQVJOcyBsaWtlOiBhcm46YXdzOnNlcnZpY2U6cmVnaW9uOmFjY291bnQ6cmVzb3VyY2VUeXBlOnJlc291cmNlTmFtZVxuICByZXR1cm4gYGFybjoke3BhcnRzLnBhcnRpdGlvbn06JHtwYXJ0cy5zZXJ2aWNlfToke3BhcnRzLnJlZ2lvbn06JHtwYXJ0cy5hY2NvdW50fToke3BhcnRzLnJlc291cmNlVHlwZX06JHtwYXJ0cy5yZXNvdXJjZU5hbWV9YDtcbn1cblxuaW50ZXJmYWNlIEludHJpbnNpYyB7XG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgYXJnczogYW55O1xufVxuXG5hc3luYyBmdW5jdGlvbiBhc3luY0dsb2JhbFJlcGxhY2Uoc3RyOiBzdHJpbmcsIHJlZ2V4OiBSZWdFeHAsIGNiOiAoeDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAoIXJlZ2V4Lmdsb2JhbCkgeyB0aHJvdyBuZXcgRXJyb3IoJ1JlZ2V4IG11c3QgYmUgY3JlYXRlZCB3aXRoIC9nIGZsYWcnKTsgfVxuXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBzdGFydCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaCkgeyBicmVhazsgfVxuXG4gICAgcmV0LnB1c2goc3RyLnN1YnN0cmluZyhzdGFydCwgbWF0Y2guaW5kZXgpKTtcbiAgICByZXQucHVzaChhd2FpdCBjYihtYXRjaFsxXSkpO1xuXG4gICAgc3RhcnQgPSByZWdleC5sYXN0SW5kZXg7XG4gIH1cbiAgcmV0LnB1c2goc3RyLnN1YnN0cihzdGFydCkpO1xuXG4gIHJldHVybiByZXQuam9pbignJyk7XG59XG4iXX0=