"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = void 0;
const common_1 = require("./common");
/**
 * Returns `false` if the change cannot be short-circuited,
 * `true` if the change is irrelevant from a short-circuit perspective
 * (like a change to CDKMetadata),
 * or a LambdaFunctionResource if the change can be short-circuited.
 */
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    var _a;
    const lambdaCodeChange = await isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate);
    if (typeof lambdaCodeChange === 'string') {
        return lambdaCodeChange;
    }
    else {
        // verify that the Asset changed - otherwise,
        // it's a Code property-only change,
        // but not to an asset change
        // (for example, going from Code.fromAsset() to Code.fromInline())
        if (!common_1.assetMetadataChanged(change)) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        const functionName = await common_1.establishResourcePhysicalName(logicalId, (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.FunctionName, evaluateCfnTemplate);
        if (!functionName) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        return new LambdaFunctionHotswapOperation({
            physicalName: functionName,
            code: lambdaCodeChange,
        });
    }
}
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
/**
 * Returns `ChangeHotswapImpact.IRRELEVANT` if the change is not for a AWS::Lambda::Function,
 * but doesn't prevent short-circuiting
 * (like a change to CDKMetadata resource),
 * `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change is to a AWS::Lambda::Function,
 * but not only to its Code property,
 * or a LambdaFunctionCode if the change is to a AWS::Lambda::Function,
 * and only affects its Code property.
 */
async function isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate) {
    const newResourceType = change.newValue.Type;
    if (newResourceType !== 'AWS::Lambda::Function') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    /*
     * On first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    let s3Bucket = '', s3Key = '';
    let foundCodeDifference = false;
    // Make sure only the code in the Lambda function changed
    const propertyUpdates = change.propertyUpdates;
    for (const updatedPropName in propertyUpdates) {
        const updatedProp = propertyUpdates[updatedPropName];
        for (const newPropName in updatedProp.newValue) {
            switch (newPropName) {
                case 'S3Bucket':
                    foundCodeDifference = true;
                    s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                    break;
                case 'S3Key':
                    foundCodeDifference = true;
                    s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                    break;
                default:
                    return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
            }
        }
    }
    return foundCodeDifference
        ? {
            s3Bucket,
            s3Key,
        }
        : common_1.ChangeHotswapImpact.IRRELEVANT;
}
class LambdaFunctionHotswapOperation {
    constructor(lambdaFunctionResource) {
        this.lambdaFunctionResource = lambdaFunctionResource;
    }
    async apply(sdk) {
        return sdk.lambda().updateFunctionCode({
            FunctionName: this.lambdaFunctionResource.physicalName,
            S3Bucket: this.lambdaFunctionResource.code.s3Bucket,
            S3Key: this.lambdaFunctionResource.code.s3Key,
        }).promise();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EscUNBQXdLO0FBR3hLOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLGtDQUFrQyxDQUN0RCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EOztJQUUzRyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sOEJBQThCLENBQUMsTUFBTSxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDM0YsSUFBSSxPQUFPLGdCQUFnQixLQUFLLFFBQVEsRUFBRTtRQUN4QyxPQUFPLGdCQUFnQixDQUFDO0tBQ3pCO1NBQU07UUFDTCw2Q0FBNkM7UUFDN0Msb0NBQW9DO1FBQ3BDLDZCQUE2QjtRQUM3QixrRUFBa0U7UUFDbEUsSUFBSSxDQUFDLDZCQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7UUFFRCxNQUFNLFlBQVksR0FBRyxNQUFNLHNDQUE2QixDQUFDLFNBQVMsUUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsMENBQUUsWUFBWSxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFDbkksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQixPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO1NBQ3JEO1FBRUQsT0FBTyxJQUFJLDhCQUE4QixDQUFDO1lBQ3hDLFlBQVksRUFBRSxZQUFZO1lBQzFCLElBQUksRUFBRSxnQkFBZ0I7U0FDdkIsQ0FBQyxDQUFDO0tBQ0o7QUFDSCxDQUFDO0FBekJELGdGQXlCQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsS0FBSyxVQUFVLDhCQUE4QixDQUMzQyxNQUFtQyxFQUFFLG1CQUFtRDtJQUV4RixNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztJQUM3QyxJQUFJLGVBQWUsS0FBSyx1QkFBdUIsRUFBRTtRQUMvQyxPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO0tBQ3JEO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILElBQUksUUFBUSxHQUFHLEVBQUUsRUFBRSxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQzlCLElBQUksbUJBQW1CLEdBQUcsS0FBSyxDQUFDO0lBQ2hDLHlEQUF5RDtJQUN6RCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDO0lBQy9DLEtBQUssTUFBTSxlQUFlLElBQUksZUFBZSxFQUFFO1FBQzdDLE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNyRCxLQUFLLE1BQU0sV0FBVyxJQUFJLFdBQVcsQ0FBQyxRQUFRLEVBQUU7WUFDOUMsUUFBUSxXQUFXLEVBQUU7Z0JBQ25CLEtBQUssVUFBVTtvQkFDYixtQkFBbUIsR0FBRyxJQUFJLENBQUM7b0JBQzNCLFFBQVEsR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztvQkFDOUYsTUFBTTtnQkFDUixLQUFLLE9BQU87b0JBQ1YsbUJBQW1CLEdBQUcsSUFBSSxDQUFDO29CQUMzQixLQUFLLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7b0JBQzNGLE1BQU07Z0JBQ1I7b0JBQ0UsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQzthQUN2RDtTQUNGO0tBQ0Y7SUFFRCxPQUFPLG1CQUFtQjtRQUN4QixDQUFDLENBQUM7WUFDQSxRQUFRO1lBQ1IsS0FBSztTQUNOO1FBQ0QsQ0FBQyxDQUFDLDRCQUFtQixDQUFDLFVBQVUsQ0FBQztBQUNyQyxDQUFDO0FBWUQsTUFBTSw4QkFBOEI7SUFDbEMsWUFBNkIsc0JBQThDO1FBQTlDLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7SUFDM0UsQ0FBQztJQUVNLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBUztRQUMxQixPQUFPLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQztZQUNyQyxZQUFZLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFlBQVk7WUFDdEQsUUFBUSxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsUUFBUTtZQUNuRCxLQUFLLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxLQUFLO1NBQzlDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNmLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBhc3NldE1ldGFkYXRhQ2hhbmdlZCwgQ2hhbmdlSG90c3dhcEltcGFjdCwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgSG90c3dhcE9wZXJhdGlvbiwgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBlc3RhYmxpc2hSZXNvdXJjZVBoeXNpY2FsTmFtZSB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuXG4vKipcbiAqIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgY2hhbmdlIGNhbm5vdCBiZSBzaG9ydC1jaXJjdWl0ZWQsXG4gKiBgdHJ1ZWAgaWYgdGhlIGNoYW5nZSBpcyBpcnJlbGV2YW50IGZyb20gYSBzaG9ydC1jaXJjdWl0IHBlcnNwZWN0aXZlXG4gKiAobGlrZSBhIGNoYW5nZSB0byBDREtNZXRhZGF0YSksXG4gKiBvciBhIExhbWJkYUZ1bmN0aW9uUmVzb3VyY2UgaWYgdGhlIGNoYW5nZSBjYW4gYmUgc2hvcnQtY2lyY3VpdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgY29uc3QgbGFtYmRhQ29kZUNoYW5nZSA9IGF3YWl0IGlzTGFtYmRhRnVuY3Rpb25Db2RlT25seUNoYW5nZShjaGFuZ2UsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpO1xuICBpZiAodHlwZW9mIGxhbWJkYUNvZGVDaGFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxhbWJkYUNvZGVDaGFuZ2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhlIEFzc2V0IGNoYW5nZWQgLSBvdGhlcndpc2UsXG4gICAgLy8gaXQncyBhIENvZGUgcHJvcGVydHktb25seSBjaGFuZ2UsXG4gICAgLy8gYnV0IG5vdCB0byBhbiBhc3NldCBjaGFuZ2VcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGdvaW5nIGZyb20gQ29kZS5mcm9tQXNzZXQoKSB0byBDb2RlLmZyb21JbmxpbmUoKSlcbiAgICBpZiAoIWFzc2V0TWV0YWRhdGFDaGFuZ2VkKGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG5cbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBhd2FpdCBlc3RhYmxpc2hSZXNvdXJjZVBoeXNpY2FsTmFtZShsb2dpY2FsSWQsIGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzPy5GdW5jdGlvbk5hbWUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpO1xuICAgIGlmICghZnVuY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMYW1iZGFGdW5jdGlvbkhvdHN3YXBPcGVyYXRpb24oe1xuICAgICAgcGh5c2ljYWxOYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICBjb2RlOiBsYW1iZGFDb2RlQ2hhbmdlLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBgQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UYCBpZiB0aGUgY2hhbmdlIGlzIG5vdCBmb3IgYSBBV1M6OkxhbWJkYTo6RnVuY3Rpb24sXG4gKiBidXQgZG9lc24ndCBwcmV2ZW50IHNob3J0LWNpcmN1aXRpbmdcbiAqIChsaWtlIGEgY2hhbmdlIHRvIENES01ldGFkYXRhIHJlc291cmNlKSxcbiAqIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVGAgaWYgdGhlIGNoYW5nZSBpcyB0byBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGJ1dCBub3Qgb25seSB0byBpdHMgQ29kZSBwcm9wZXJ0eSxcbiAqIG9yIGEgTGFtYmRhRnVuY3Rpb25Db2RlIGlmIHRoZSBjaGFuZ2UgaXMgdG8gYSBBV1M6OkxhbWJkYTo6RnVuY3Rpb24sXG4gKiBhbmQgb25seSBhZmZlY3RzIGl0cyBDb2RlIHByb3BlcnR5LlxuICovXG5hc3luYyBmdW5jdGlvbiBpc0xhbWJkYUZ1bmN0aW9uQ29kZU9ubHlDaGFuZ2UoXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPExhbWJkYUZ1bmN0aW9uQ29kZSB8IENoYW5nZUhvdHN3YXBJbXBhY3Q+IHtcbiAgY29uc3QgbmV3UmVzb3VyY2VUeXBlID0gY2hhbmdlLm5ld1ZhbHVlLlR5cGU7XG4gIGlmIChuZXdSZXNvdXJjZVR5cGUgIT09ICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgLypcbiAgICogT24gZmlyc3QgZ2xhbmNlLCB3ZSB3b3VsZCB3YW50IHRvIGluaXRpYWxpemUgdGhlc2UgdXNpbmcgdGhlIFwicHJldmlvdXNcIiB2YWx1ZXMgKGNoYW5nZS5vbGRWYWx1ZSksXG4gICAqIGluIGNhc2Ugb25seSBvbmUgb2YgdGhlbSBjaGFuZ2VkLCBsaWtlIHRoZSBrZXksIGFuZCB0aGUgQnVja2V0IHN0YXllZCB0aGUgc2FtZS5cbiAgICogSG93ZXZlciwgdGhhdCBhY3R1YWxseSBmYWlscyBmb3Igb2xkLXN0eWxlIHN5bnRoZXNpcywgd2hpY2ggdXNlcyBDRk4gUGFyYW1ldGVycyFcbiAgICogQmVjYXVzZSB0aGUgbmFtZXMgb2YgdGhlIFBhcmFtZXRlcnMgZGVwZW5kIG9uIHRoZSBoYXNoIG9mIHRoZSBBc3NldCxcbiAgICogdGhlIFBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIFwib2xkXCIgdmFsdWVzIG5vIGxvbmdlciBleGlzdCBpbiBgYXNzZXRQYXJhbXNgIGF0IHRoaXMgcG9pbnQsXG4gICAqIHdoaWNoIG1lYW5zIHdlIGRvbid0IGhhdmUgdGhlIGNvcnJlY3QgdmFsdWVzIGF2YWlsYWJsZSB0byBldmFsdWF0ZSB0aGUgQ0ZOIGV4cHJlc3Npb24gd2l0aC5cbiAgICogRm9ydHVuYXRlbHksIHRoZSBkaWZmIHdpbGwgYWx3YXlzIGluY2x1ZGUgYm90aCB0aGUgczNCdWNrZXQgYW5kIHMzS2V5IHBhcnRzIG9mIHRoZSBMYW1iZGEncyBDb2RlIHByb3BlcnR5LFxuICAgKiBldmVuIGlmIG9ubHkgb25lIG9mIHRoZW0gd2FzIGFjdHVhbGx5IGNoYW5nZWQsXG4gICAqIHdoaWNoIG1lYW5zIHdlIGRvbid0IG5lZWQgdGhlIFwib2xkXCIgdmFsdWVzIGF0IGFsbCwgYW5kIHdlIGNhbiBzYWZlbHkgaW5pdGlhbGl6ZSB0aGVzZSB3aXRoIGp1c3QgYCcnYC5cbiAgICovXG4gIGxldCBzM0J1Y2tldCA9ICcnLCBzM0tleSA9ICcnO1xuICBsZXQgZm91bmRDb2RlRGlmZmVyZW5jZSA9IGZhbHNlO1xuICAvLyBNYWtlIHN1cmUgb25seSB0aGUgY29kZSBpbiB0aGUgTGFtYmRhIGZ1bmN0aW9uIGNoYW5nZWRcbiAgY29uc3QgcHJvcGVydHlVcGRhdGVzID0gY2hhbmdlLnByb3BlcnR5VXBkYXRlcztcbiAgZm9yIChjb25zdCB1cGRhdGVkUHJvcE5hbWUgaW4gcHJvcGVydHlVcGRhdGVzKSB7XG4gICAgY29uc3QgdXBkYXRlZFByb3AgPSBwcm9wZXJ0eVVwZGF0ZXNbdXBkYXRlZFByb3BOYW1lXTtcbiAgICBmb3IgKGNvbnN0IG5ld1Byb3BOYW1lIGluIHVwZGF0ZWRQcm9wLm5ld1ZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKG5ld1Byb3BOYW1lKSB7XG4gICAgICAgIGNhc2UgJ1MzQnVja2V0JzpcbiAgICAgICAgICBmb3VuZENvZGVEaWZmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgICBzM0J1Y2tldCA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1MzS2V5JzpcbiAgICAgICAgICBmb3VuZENvZGVEaWZmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgICBzM0tleSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3VuZENvZGVEaWZmZXJlbmNlXG4gICAgPyB7XG4gICAgICBzM0J1Y2tldCxcbiAgICAgIHMzS2V5LFxuICAgIH1cbiAgICA6IENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVDtcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uQ29kZSB7XG4gIHJlYWRvbmx5IHMzQnVja2V0OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHMzS2V5OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvblJlc291cmNlIHtcbiAgcmVhZG9ubHkgcGh5c2ljYWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNvZGU6IExhbWJkYUZ1bmN0aW9uQ29kZTtcbn1cblxuY2xhc3MgTGFtYmRhRnVuY3Rpb25Ib3Rzd2FwT3BlcmF0aW9uIGltcGxlbWVudHMgSG90c3dhcE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgbGFtYmRhRnVuY3Rpb25SZXNvdXJjZTogTGFtYmRhRnVuY3Rpb25SZXNvdXJjZSkge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFwcGx5KHNkazogSVNESyk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHNkay5sYW1iZGEoKS51cGRhdGVGdW5jdGlvbkNvZGUoe1xuICAgICAgRnVuY3Rpb25OYW1lOiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lLFxuICAgICAgUzNCdWNrZXQ6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5jb2RlLnMzQnVja2V0LFxuICAgICAgUzNLZXk6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5jb2RlLnMzS2V5LFxuICAgIH0pLnByb21pc2UoKTtcbiAgfVxufVxuIl19