"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate) {
    // the only resource change we should allow is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    for (const updatedPropName in change.propertyUpdates) {
        // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
        // it contains the image and environment variables, so seems like a safe bet for now.
        // We might revisit this decision in the future though!
        if (updatedPropName !== 'ContainerDefinitions') {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        const containerDefinitionsDifference = (change.propertyUpdates)[updatedPropName];
        if (containerDefinitionsDifference.newValue === undefined) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    // at this point, we know the TaskDefinition can be hotswapped
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0 ||
        resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if there are either no resources referencing the TaskDefinition,
        // or something besides an ECS Service is referencing it,
        // hotswap is not possible
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const taskDefinitionResource = change.newValue.Properties;
    // first, let's get the name of the family
    const familyNameOrArn = await common_1.establishResourcePhysicalName(logicalId, taskDefinitionResource === null || taskDefinitionResource === void 0 ? void 0 : taskDefinitionResource.Family, evaluateCfnTemplate);
    if (!familyNameOrArn) {
        // if the Family property has not bee provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    const evaluatedTaskDef = {
        ...await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource !== null && taskDefinitionResource !== void 0 ? taskDefinitionResource : {}),
            Family: undefined,
        }),
        Family: family,
    };
    return new EcsServiceHotswapOperation(evaluatedTaskDef, ecsServicesReferencingTaskDef);
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
class EcsServiceHotswapOperation {
    constructor(taskDefinitionResource, servicesReferencingTaskDef) {
        this.taskDefinitionResource = taskDefinitionResource;
        this.servicesReferencingTaskDef = servicesReferencingTaskDef;
    }
    async apply(sdk) {
        var _a;
        // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
        // we need to lowercase the evaluated TaskDef from CloudFormation,
        // as the AWS SDK uses lowercase property names for these
        const lowercasedTaskDef = lowerCaseFirstCharacterOfObjectKeys(this.taskDefinitionResource);
        const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
        const taskDefRevArn = (_a = registerTaskDefResponse.taskDefinition) === null || _a === void 0 ? void 0 : _a.taskDefinitionArn;
        // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
        const servicePerClusterUpdates = {};
        for (const ecsService of this.servicesReferencingTaskDef) {
            const clusterName = ecsService.serviceArn.split('/')[1];
            const existingClusterPromises = servicePerClusterUpdates[clusterName];
            let clusterPromises;
            if (existingClusterPromises) {
                clusterPromises = existingClusterPromises;
            }
            else {
                clusterPromises = [];
                servicePerClusterUpdates[clusterName] = clusterPromises;
            }
            clusterPromises.push({
                promise: sdk.ecs().updateService({
                    service: ecsService.serviceArn,
                    taskDefinition: taskDefRevArn,
                    cluster: clusterName,
                    forceNewDeployment: true,
                    deploymentConfiguration: {
                        minimumHealthyPercent: 0,
                    },
                }).promise(),
                ecsService: ecsService,
            });
        }
        await Promise.all(Object.values(servicePerClusterUpdates)
            .map(clusterUpdates => {
            return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
        }));
        // Step 3 - wait for the service deployments triggered in Step 2 to finish
        // configure a custom Waiter
        sdk.ecs().api.waiters.deploymentToFinish = {
            name: 'DeploymentToFinish',
            operation: 'describeServices',
            delay: 10,
            maxAttempts: 60,
            acceptors: [
                {
                    matcher: 'pathAny',
                    argument: 'failures[].reason',
                    expected: 'MISSING',
                    state: 'failure',
                },
                {
                    matcher: 'pathAny',
                    argument: 'services[].status',
                    expected: 'DRAINING',
                    state: 'failure',
                },
                {
                    matcher: 'pathAny',
                    argument: 'services[].status',
                    expected: 'INACTIVE',
                    state: 'failure',
                },
                {
                    matcher: 'path',
                    argument: "length(services[].deployments[? status == 'PRIMARY' && runningCount < desiredCount][]) == `0`",
                    expected: true,
                    state: 'success',
                },
            ],
        };
        // create a custom Waiter that uses the deploymentToFinish configuration added above
        const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentToFinish');
        // wait for all of the waiters to finish
        return Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
            return deploymentWaiter.wait({
                cluster: clusterName,
                services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
            }).promise();
        }));
    }
}
function lowerCaseFirstCharacterOfObjectKeys(val) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        return val.map(lowerCaseFirstCharacterOfObjectKeys);
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        ret[lowerCaseFirstCharacter(k)] = lowerCaseFirstCharacterOfObjectKeys(v);
    }
    return ret;
}
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.substr(1)}` : str;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUUvQixxQ0FBa0o7QUFHM0ksS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EO0lBRTNHLG9FQUFvRTtJQUNwRSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFO1FBQ3ZELE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7S0FDckQ7SUFFRCxLQUFLLE1BQU0sZUFBZSxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUU7UUFDcEQscUZBQXFGO1FBQ3JGLHFGQUFxRjtRQUNyRix1REFBdUQ7UUFDdkQsSUFBSSxlQUFlLEtBQUssc0JBQXNCLEVBQUU7WUFDOUMsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQztTQUNyRDtRQUNELE1BQU0sOEJBQThCLEdBQUcsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDakYsSUFBSSw4QkFBOEIsQ0FBQyxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQ3pELE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7S0FDRjtJQUNELDhEQUE4RDtJQUU5RCx1RUFBdUU7SUFDdkUsTUFBTSwyQkFBMkIsR0FBRyxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRixNQUFNLHFDQUFxQyxHQUFHLDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssbUJBQW1CLENBQUMsQ0FBQztJQUN0SCxNQUFNLDZCQUE2QixHQUFHLElBQUksS0FBSyxFQUFjLENBQUM7SUFDOUQsS0FBSyxNQUFNLGtCQUFrQixJQUFJLHFDQUFxQyxFQUFFO1FBQ3RFLE1BQU0sVUFB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QU8sR0FBRyxDQUFDO0tBQ1o7SUFDRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7S0FDckQ7SUFDRCxNQUFNLEdBQUcsR0FBMEIsRUFBRSxDQUFDO0lBQ3RDLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3hDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLG1DQUFtQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzFFO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQsU0FBUyx1QkFBdUIsQ0FBQyxHQUFXO0lBQzFDLE9BQU8sR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgQ2hhbmdlSG90c3dhcEltcGFjdCwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUsIEhvdHN3YXBPcGVyYXRpb24sIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlKFxuICBsb2dpY2FsSWQ6IHN0cmluZywgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4ge1xuICAvLyB0aGUgb25seSByZXNvdXJjZSBjaGFuZ2Ugd2Ugc2hvdWxkIGFsbG93IGlzIGFuIEVDUyBUYXNrRGVmaW5pdGlvblxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09ICdBV1M6OkVDUzo6VGFza0RlZmluaXRpb24nKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgZm9yIChjb25zdCB1cGRhdGVkUHJvcE5hbWUgaW4gY2hhbmdlLnByb3BlcnR5VXBkYXRlcykge1xuICAgIC8vIFdlIG9ubHkgYWxsb3cgYSBjaGFuZ2UgaW4gdGhlIENvbnRhaW5lckRlZmluaXRpb25zIG9mIHRoZSBUYXNrRGVmaW5pdGlvbiBmb3Igbm93IC1cbiAgICAvLyBpdCBjb250YWlucyB0aGUgaW1hZ2UgYW5kIGVudmlyb25tZW50IHZhcmlhYmxlcywgc28gc2VlbXMgbGlrZSBhIHNhZmUgYmV0IGZvciBub3cuXG4gICAgLy8gV2UgbWlnaHQgcmV2aXNpdCB0aGlzIGRlY2lzaW9uIGluIHRoZSBmdXR1cmUgdGhvdWdoIVxuICAgIGlmICh1cGRhdGVkUHJvcE5hbWUgIT09ICdDb250YWluZXJEZWZpbml0aW9ucycpIHtcbiAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyRGVmaW5pdGlvbnNEaWZmZXJlbmNlID0gKGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpW3VwZGF0ZWRQcm9wTmFtZV07XG4gICAgaWYgKGNvbnRhaW5lckRlZmluaXRpb25zRGlmZmVyZW5jZS5uZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuICB9XG4gIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGtub3cgdGhlIFRhc2tEZWZpbml0aW9uIGNhbiBiZSBob3Rzd2FwcGVkXG5cbiAgLy8gZmluZCBhbGwgRUNTIFNlcnZpY2VzIHRoYXQgcmVmZXJlbmNlIHRoZSBUYXNrRGVmaW5pdGlvbiB0aGF0IGNoYW5nZWRcbiAgY29uc3QgcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUmVmZXJlbmNlc1RvKGxvZ2ljYWxJZCk7XG4gIGNvbnN0IGVjc1NlcnZpY2VSZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYuZmlsdGVyKHIgPT4gci5UeXBlID09PSAnQVdTOjpFQ1M6OlNlcnZpY2UnKTtcbiAgY29uc3QgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBuZXcgQXJyYXk8RWNzU2VydmljZT4oKTtcbiAgZm9yIChjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2Ugb2YgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgIGNvbnN0IHNlcnZpY2VBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRQaHlzaWNhbE5hbWVGb3IoZWNzU2VydmljZVJlc291cmNlLkxvZ2ljYWxJZCk7XG4gICAgaWYgKHNlcnZpY2VBcm4pIHtcbiAgICAgIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLnB1c2goeyBzZXJ2aWNlQXJuIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID09PSAwIHx8XG4gICAgICByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID4gZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIGVpdGhlciBubyByZXNvdXJjZXMgcmVmZXJlbmNpbmcgdGhlIFRhc2tEZWZpbml0aW9uLFxuICAgIC8vIG9yIHNvbWV0aGluZyBiZXNpZGVzIGFuIEVDUyBTZXJ2aWNlIGlzIHJlZmVyZW5jaW5nIGl0LFxuICAgIC8vIGhvdHN3YXAgaXMgbm90IHBvc3NpYmxlXG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgY29uc3QgdGFza0RlZmluaXRpb25SZXNvdXJjZSA9IGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzO1xuICAvLyBmaXJzdCwgbGV0J3MgZ2V0IHRoZSBuYW1lIG9mIHRoZSBmYW1pbHlcbiAgY29uc3QgZmFtaWx5TmFtZU9yQXJuID0gYXdhaXQgZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUobG9naWNhbElkLCB0YXNrRGVmaW5pdGlvblJlc291cmNlPy5GYW1pbHksIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpO1xuICBpZiAoIWZhbWlseU5hbWVPckFybikge1xuICAgIC8vIGlmIHRoZSBGYW1pbHkgcHJvcGVydHkgaGFzIG5vdCBiZWUgcHJvdmlkZWQsIGFuZCB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBjdXJyZW50IFN0YWNrLFxuICAgIC8vIHRoaXMgbWVhbnMgaG90c3dhcHBpbmcgaXMgbm90IHBvc3NpYmxlXG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG4gIC8vIHRoZSBwaHlzaWNhbCBuYW1lIG9mIHRoZSBUYXNrIERlZmluaXRpb24gaW4gQ2xvdWRGb3JtYXRpb24gaW5jbHVkZXMgaXRzIGN1cnJlbnQgcmV2aXNpb24gbnVtYmVyIGF0IHRoZSBlbmQsXG4gIC8vIHJlbW92ZSBpdCBpZiBuZWVkZWRcbiAgY29uc3QgZmFtaWx5TmFtZU9yQXJuUGFydHMgPSBmYW1pbHlOYW1lT3JBcm4uc3BsaXQoJzonKTtcbiAgY29uc3QgZmFtaWx5ID0gZmFtaWx5TmFtZU9yQXJuUGFydHMubGVuZ3RoID4gMVxuICAgIC8vIGZhbWlseU5hbWVPckFybiBpcyBhY3R1YWxseSBhbiBBUk4sIG9mIHRoZSBmb3JtYXQgJ2Fybjphd3M6ZWNzOnJlZ2lvbjphY2NvdW50OnRhc2stZGVmaW5pdGlvbi88ZmFtaWx5LW5hbWU+OjxyZXZpc2lvbi1ucj4nXG4gICAgLy8gc28sIHRha2UgdGhlIDZ0aCBlbGVtZW50LCBhdCBpbmRleCA1LCBhbmQgc3BsaXQgaXQgb24gJy8nXG4gICAgPyBmYW1pbHlOYW1lT3JBcm5QYXJ0c1s1XS5zcGxpdCgnLycpWzFdXG4gICAgLy8gb3RoZXJ3aXNlLCBmYW1pbHlOYW1lT3JBcm4gaXMganVzdCB0aGUgc2ltcGxlIG5hbWUgZXZhbHVhdGVkIGZyb20gdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAgOiBmYW1pbHlOYW1lT3JBcm47XG4gIC8vIHRoZW4sIGxldCdzIGV2YWx1YXRlIHRoZSBib2R5IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIFRhc2tEZWYgKHdpdGhvdXQgdGhlIEZhbWlseSBwcm9wZXJ0eSlcbiAgY29uc3QgZXZhbHVhdGVkVGFza0RlZiA9IHtcbiAgICAuLi5hd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih7XG4gICAgICAuLi4odGFza0RlZmluaXRpb25SZXNvdXJjZSA/PyB7fSksXG4gICAgICBGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICB9KSxcbiAgICBGYW1pbHk6IGZhbWlseSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBFY3NTZXJ2aWNlSG90c3dhcE9wZXJhdGlvbihldmFsdWF0ZWRUYXNrRGVmLCBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZik7XG59XG5cbmludGVyZmFjZSBFY3NTZXJ2aWNlIHtcbiAgcmVhZG9ubHkgc2VydmljZUFybjogc3RyaW5nO1xufVxuXG5jbGFzcyBFY3NTZXJ2aWNlSG90c3dhcE9wZXJhdGlvbiBpbXBsZW1lbnRzIEhvdHN3YXBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhc2tEZWZpbml0aW9uUmVzb3VyY2U6IGFueSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmOiBFY3NTZXJ2aWNlW10sXG4gICkge31cblxuICBwdWJsaWMgYXN5bmMgYXBwbHkoc2RrOiBJU0RLKTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyBTdGVwIDEgLSB1cGRhdGUgdGhlIGNoYW5nZWQgVGFza0RlZmluaXRpb24sIGNyZWF0aW5nIGEgbmV3IFRhc2tEZWZpbml0aW9uIFJldmlzaW9uXG4gICAgLy8gd2UgbmVlZCB0byBsb3dlcmNhc2UgdGhlIGV2YWx1YXRlZCBUYXNrRGVmIGZyb20gQ2xvdWRGb3JtYXRpb24sXG4gICAgLy8gYXMgdGhlIEFXUyBTREsgdXNlcyBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgZm9yIHRoZXNlXG4gICAgY29uc3QgbG93ZXJjYXNlZFRhc2tEZWYgPSBsb3dlckNhc2VGaXJzdENoYXJhY3Rlck9mT2JqZWN0S2V5cyh0aGlzLnRhc2tEZWZpbml0aW9uUmVzb3VyY2UpO1xuICAgIGNvbnN0IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlID0gYXdhaXQgc2RrLmVjcygpLnJlZ2lzdGVyVGFza0RlZmluaXRpb24obG93ZXJjYXNlZFRhc2tEZWYpLnByb21pc2UoKTtcbiAgICBjb25zdCB0YXNrRGVmUmV2QXJuID0gcmVnaXN0ZXJUYXNrRGVmUmVzcG9uc2UudGFza0RlZmluaXRpb24/LnRhc2tEZWZpbml0aW9uQXJuO1xuXG4gICAgLy8gU3RlcCAyIC0gdXBkYXRlIHRoZSBzZXJ2aWNlcyB1c2luZyB0aGF0IFRhc2tEZWZpbml0aW9uIHRvIHBvaW50IHRvIHRoZSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICBjb25zdCBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXM6IHsgW2NsdXN0ZXI6IHN0cmluZ106IEFycmF5PHsgcHJvbWlzZTogUHJvbWlzZTxhbnk+LCBlY3NTZXJ2aWNlOiBFY3NTZXJ2aWNlIH0+IH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVjc1NlcnZpY2Ugb2YgdGhpcy5zZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgICAgY29uc3QgY2x1c3Rlck5hbWUgPSBlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsxXTtcblxuICAgICAgY29uc3QgZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMgPSBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXNbY2x1c3Rlck5hbWVdO1xuICAgICAgbGV0IGNsdXN0ZXJQcm9taXNlczogQXJyYXk8eyBwcm9taXNlOiBQcm9taXNlPGFueT4sIGVjc1NlcnZpY2U6IEVjc1NlcnZpY2UgfT47XG4gICAgICBpZiAoZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMpIHtcbiAgICAgICAgY2x1c3RlclByb21pc2VzID0gZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbHVzdGVyUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzW2NsdXN0ZXJOYW1lXSA9IGNsdXN0ZXJQcm9taXNlcztcbiAgICAgIH1cblxuICAgICAgY2x1c3RlclByb21pc2VzLnB1c2goe1xuICAgICAgICBwcm9taXNlOiBzZGsuZWNzKCkudXBkYXRlU2VydmljZSh7XG4gICAgICAgICAgc2VydmljZTogZWNzU2VydmljZS5zZXJ2aWNlQXJuLFxuICAgICAgICAgIHRhc2tEZWZpbml0aW9uOiB0YXNrRGVmUmV2QXJuLFxuICAgICAgICAgIGNsdXN0ZXI6IGNsdXN0ZXJOYW1lLFxuICAgICAgICAgIGZvcmNlTmV3RGVwbG95bWVudDogdHJ1ZSxcbiAgICAgICAgICBkZXBsb3ltZW50Q29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgbWluaW11bUhlYWx0aHlQZXJjZW50OiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLnByb21pc2UoKSxcbiAgICAgICAgZWNzU2VydmljZTogZWNzU2VydmljZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlcylcbiAgICAgIC5tYXAoY2x1c3RlclVwZGF0ZXMgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2x1c3RlclVwZGF0ZXMubWFwKHNlcnZpY2VVcGRhdGUgPT4gc2VydmljZVVwZGF0ZS5wcm9taXNlKSk7XG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgLy8gU3RlcCAzIC0gd2FpdCBmb3IgdGhlIHNlcnZpY2UgZGVwbG95bWVudHMgdHJpZ2dlcmVkIGluIFN0ZXAgMiB0byBmaW5pc2hcbiAgICAvLyBjb25maWd1cmUgYSBjdXN0b20gV2FpdGVyXG4gICAgKHNkay5lY3MoKSBhcyBhbnkpLmFwaS53YWl0ZXJzLmRlcGxveW1lbnRUb0ZpbmlzaCA9IHtcbiAgICAgIG5hbWU6ICdEZXBsb3ltZW50VG9GaW5pc2gnLFxuICAgICAgb3BlcmF0aW9uOiAnZGVzY3JpYmVTZXJ2aWNlcycsXG4gICAgICBkZWxheTogMTAsXG4gICAgICBtYXhBdHRlbXB0czogNjAsXG4gICAgICBhY2NlcHRvcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoQW55JyxcbiAgICAgICAgICBhcmd1bWVudDogJ2ZhaWx1cmVzW10ucmVhc29uJyxcbiAgICAgICAgICBleHBlY3RlZDogJ01JU1NJTkcnLFxuICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgYXJndW1lbnQ6ICdzZXJ2aWNlc1tdLnN0YXR1cycsXG4gICAgICAgICAgZXhwZWN0ZWQ6ICdEUkFJTklORycsXG4gICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoQW55JyxcbiAgICAgICAgICBhcmd1bWVudDogJ3NlcnZpY2VzW10uc3RhdHVzJyxcbiAgICAgICAgICBleHBlY3RlZDogJ0lOQUNUSVZFJyxcbiAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcjogJ3BhdGgnLFxuICAgICAgICAgIGFyZ3VtZW50OiBcImxlbmd0aChzZXJ2aWNlc1tdLmRlcGxveW1lbnRzWz8gc3RhdHVzID09ICdQUklNQVJZJyAmJiBydW5uaW5nQ291bnQgPCBkZXNpcmVkQ291bnRdW10pID09IGAwYFwiLFxuICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgIHN0YXRlOiAnc3VjY2VzcycsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gICAgLy8gY3JlYXRlIGEgY3VzdG9tIFdhaXRlciB0aGF0IHVzZXMgdGhlIGRlcGxveW1lbnRUb0ZpbmlzaCBjb25maWd1cmF0aW9uIGFkZGVkIGFib3ZlXG4gICAgY29uc3QgZGVwbG95bWVudFdhaXRlciA9IG5ldyAoQVdTIGFzIGFueSkuUmVzb3VyY2VXYWl0ZXIoc2RrLmVjcygpLCAnZGVwbG95bWVudFRvRmluaXNoJyk7XG4gICAgLy8gd2FpdCBmb3IgYWxsIG9mIHRoZSB3YWl0ZXJzIHRvIGZpbmlzaFxuICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXMpLm1hcCgoW2NsdXN0ZXJOYW1lLCBzZXJ2aWNlVXBkYXRlc10pID0+IHtcbiAgICAgIHJldHVybiBkZXBsb3ltZW50V2FpdGVyLndhaXQoe1xuICAgICAgICBjbHVzdGVyOiBjbHVzdGVyTmFtZSxcbiAgICAgICAgc2VydmljZXM6IHNlcnZpY2VVcGRhdGVzLm1hcChzZXJ2aWNlVXBkYXRlID0+IHNlcnZpY2VVcGRhdGUuZWNzU2VydmljZS5zZXJ2aWNlQXJuKSxcbiAgICAgIH0pLnByb21pc2UoKTtcbiAgICB9KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXJPZk9iamVjdEtleXModmFsOiBhbnkpOiBhbnkge1xuICBpZiAodmFsID09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLm1hcChsb3dlckNhc2VGaXJzdENoYXJhY3Rlck9mT2JqZWN0S2V5cyk7XG4gIH1cbiAgY29uc3QgcmV0OiB7IFtrOiBzdHJpbmddOiBhbnk7IH0gPSB7fTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgIHJldFtsb3dlckNhc2VGaXJzdENoYXJhY3RlcihrKV0gPSBsb3dlckNhc2VGaXJzdENoYXJhY3Rlck9mT2JqZWN0S2V5cyh2KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBsb3dlckNhc2VGaXJzdENoYXJhY3RlcihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIubGVuZ3RoID4gMCA/IGAke3N0clswXS50b0xvd2VyQ2FzZSgpfSR7c3RyLnN1YnN0cigxKX1gIDogc3RyO1xufVxuIl19