"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyContextProviderPlugin = void 0;
const cxapi = require("@aws-cdk/cx-api");
const api_1 = require("../api");
const logging_1 = require("../logging");
class KeyContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const account = args.account;
        const region = args.region;
        const options = { assumeRoleArn: args.lookupRoleArn };
        const kms = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(account, region), api_1.Mode.ForReading, options)).kms();
        const aliasListEntry = await this.findKey(kms, args);
        return this.readKeyProps(aliasListEntry, args);
    }
    async findKey(kms, args) {
        logging_1.debug(`Listing keys in ${args.account}:${args.region}`);
        let response;
        let nextMarker;
        do {
            response = await kms.listAliases({
                Marker: nextMarker,
            }).promise();
            const aliases = response.Aliases || [];
            for (const alias of aliases) {
                if (alias.AliasName == args.aliasName) {
                    return alias;
                }
            }
            nextMarker = response.NextMarker;
        } while (response.Truncated);
        throw new Error(`Could not find any key with alias named ${args.aliasName}`);
    }
    async readKeyProps(alias, args) {
        if (!alias.TargetKeyId) {
            throw new Error(`Could not find any key with alias named ${args.aliasName}`);
        }
        logging_1.debug(`Key found ${alias.TargetKeyId}`);
        return {
            keyId: alias.TargetKeyId,
        };
    }
}
exports.KeyContextProviderPlugin = KeyContextProviderPlugin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImtleXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EseUNBQXlDO0FBR3pDLGdDQUEyQztBQUMzQyx3Q0FBbUM7QUFHbkMsTUFBYSx3QkFBd0I7SUFFbkMsWUFBNkIsR0FBZ0I7UUFBaEIsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUM3QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUE4QjtRQUNsRCxNQUFNLE9BQU8sR0FBVyxJQUFJLENBQUMsT0FBUSxDQUFDO1FBQ3RDLE1BQU0sTUFBTSxHQUFXLElBQUksQ0FBQyxNQUFPLENBQUM7UUFFcEMsTUFBTSxPQUFPLEdBQUcsRUFBRSxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3RELE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsRUFBRSxVQUFJLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFMUgsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUVyRCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFTyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQVksRUFBRSxJQUE4QjtRQUVoRSxlQUFLLENBQUMsbUJBQW1CLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFFeEQsSUFBSSxRQUFrRSxDQUFDO1FBQ3ZFLElBQUksVUFBOEIsQ0FBQztRQUNuQyxHQUFHO1lBQ0QsUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLFdBQVcsQ0FBQztnQkFDL0IsTUFBTSxFQUFFLFVBQVU7YUFDbkIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBRWIsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUM7WUFDdkMsS0FBSyxNQUFNLEtBQUssSUFBSSxPQUFPLEVBQUU7Z0JBQzNCLElBQUksS0FBSyxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO29CQUNyQyxPQUFPLEtBQUssQ0FBQztpQkFDZDthQUNGO1lBRUQsVUFBVSxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUM7U0FDbEMsUUFBUSxRQUFRLENBQUMsU0FBUyxFQUFFO1FBRTdCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFTyxLQUFLLENBQUMsWUFBWSxDQUFDLEtBQTZCLEVBQUUsSUFBOEI7UUFDdEYsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUU7WUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7U0FDOUU7UUFFRCxlQUFLLENBQUMsYUFBYSxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUV4QyxPQUFPO1lBQ0wsS0FBSyxFQUFFLEtBQUssQ0FBQyxXQUFXO1NBQ3pCLENBQUM7SUFDSixDQUFDO0NBRUY7QUFyREQsNERBcURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hzY2hlbWEgZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBQcm9taXNlUmVzdWx0IH0gZnJvbSAnYXdzLXNkay9saWIvcmVxdWVzdCc7XG5pbXBvcnQgeyBNb2RlLCBTZGtQcm92aWRlciB9IGZyb20gJy4uL2FwaSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgQ29udGV4dFByb3ZpZGVyUGx1Z2luIH0gZnJvbSAnLi9wcm92aWRlcic7XG5cbmV4cG9ydCBjbGFzcyBLZXlDb250ZXh0UHJvdmlkZXJQbHVnaW4gaW1wbGVtZW50cyBDb250ZXh0UHJvdmlkZXJQbHVnaW4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXdzOiBTZGtQcm92aWRlcikge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFZhbHVlKGFyZ3M6IGN4c2NoZW1hLktleUNvbnRleHRRdWVyeSkge1xuICAgIGNvbnN0IGFjY291bnQ6IHN0cmluZyA9IGFyZ3MuYWNjb3VudCE7XG4gICAgY29uc3QgcmVnaW9uOiBzdHJpbmcgPSBhcmdzLnJlZ2lvbiE7XG5cbiAgICBjb25zdCBvcHRpb25zID0geyBhc3N1bWVSb2xlQXJuOiBhcmdzLmxvb2t1cFJvbGVBcm4gfTtcbiAgICBjb25zdCBrbXMgPSAoYXdhaXQgdGhpcy5hd3MuZm9yRW52aXJvbm1lbnQoY3hhcGkuRW52aXJvbm1lbnRVdGlscy5tYWtlKGFjY291bnQsIHJlZ2lvbiksIE1vZGUuRm9yUmVhZGluZywgb3B0aW9ucykpLmttcygpO1xuXG4gICAgY29uc3QgYWxpYXNMaXN0RW50cnkgPSBhd2FpdCB0aGlzLmZpbmRLZXkoa21zLCBhcmdzKTtcblxuICAgIHJldHVybiB0aGlzLnJlYWRLZXlQcm9wcyhhbGlhc0xpc3RFbnRyeSwgYXJncyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZpbmRLZXkoa21zOiBBV1MuS01TLCBhcmdzOiBjeHNjaGVtYS5LZXlDb250ZXh0UXVlcnkpOiBQcm9taXNlPEFXUy5LTVMuQWxpYXNMaXN0RW50cnk+IHtcblxuICAgIGRlYnVnKGBMaXN0aW5nIGtleXMgaW4gJHthcmdzLmFjY291bnR9OiR7YXJncy5yZWdpb259YCk7XG5cbiAgICBsZXQgcmVzcG9uc2U6IFByb21pc2VSZXN1bHQ8QVdTLktNUy5MaXN0QWxpYXNlc1Jlc3BvbnNlLCBBV1MuQVdTRXJyb3I+O1xuICAgIGxldCBuZXh0TWFya2VyOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZG8ge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBrbXMubGlzdEFsaWFzZXMoe1xuICAgICAgICBNYXJrZXI6IG5leHRNYXJrZXIsXG4gICAgICB9KS5wcm9taXNlKCk7XG5cbiAgICAgIGNvbnN0IGFsaWFzZXMgPSByZXNwb25zZS5BbGlhc2VzIHx8IFtdO1xuICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgIGlmIChhbGlhcy5BbGlhc05hbWUgPT0gYXJncy5hbGlhc05hbWUpIHtcbiAgICAgICAgICByZXR1cm4gYWxpYXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dE1hcmtlciA9IHJlc3BvbnNlLk5leHRNYXJrZXI7XG4gICAgfSB3aGlsZSAocmVzcG9uc2UuVHJ1bmNhdGVkKTtcblxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IGtleSB3aXRoIGFsaWFzIG5hbWVkICR7YXJncy5hbGlhc05hbWV9YCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlYWRLZXlQcm9wcyhhbGlhczogQVdTLktNUy5BbGlhc0xpc3RFbnRyeSwgYXJnczogY3hzY2hlbWEuS2V5Q29udGV4dFF1ZXJ5KTogUHJvbWlzZTxjeGFwaS5LZXlDb250ZXh0UmVzcG9uc2U+IHtcbiAgICBpZiAoIWFsaWFzLlRhcmdldEtleUlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGFueSBrZXkgd2l0aCBhbGlhcyBuYW1lZCAke2FyZ3MuYWxpYXNOYW1lfWApO1xuICAgIH1cblxuICAgIGRlYnVnKGBLZXkgZm91bmQgJHthbGlhcy5UYXJnZXRLZXlJZH1gKTtcblxuICAgIHJldHVybiB7XG4gICAgICBrZXlJZDogYWxpYXMuVGFyZ2V0S2V5SWQsXG4gICAgfTtcbiAgfVxuXG59Il19